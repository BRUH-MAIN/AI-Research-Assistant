[
  {
    "schema": "auth",
    "function_name": "email",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION auth.email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.email', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'email')\n  )::text\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "jwt",
    "arguments": "",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION auth.jwt()\n RETURNS jsonb\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n    coalesce(\n        nullif(current_setting('request.jwt.claim', true), ''),\n        nullif(current_setting('request.jwt.claims', true), '')\n    )::jsonb\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "role",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION auth.role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.role', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'role')\n  )::text\n$function$\n"
  },
  {
    "schema": "auth",
    "function_name": "uid",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION auth.uid()\n RETURNS uuid\n LANGUAGE sql\n STABLE\nAS $function$\n  select \n  coalesce(\n    nullif(current_setting('request.jwt.claim.sub', true), ''),\n    (nullif(current_setting('request.jwt.claims', true), '')::jsonb ->> 'sub')\n  )::uuid\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "armor",
    "arguments": "bytea, text[], text[]",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea, text[], text[])\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "armor",
    "arguments": "bytea",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.armor(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_armor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "crypt",
    "arguments": "text, text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.crypt(text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_crypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "dearmor",
    "arguments": "text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.dearmor(text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_dearmor$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "decrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.decrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "digest",
    "arguments": "text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.digest(text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "digest",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.digest(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_digest$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "encrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "encrypt_iv",
    "arguments": "bytea, bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.encrypt_iv(bytea, bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_random_bytes",
    "arguments": "integer",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_bytes(integer)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_random_bytes$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_random_uuid",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.gen_random_uuid()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE\nAS '$libdir/pgcrypto', $function$pg_random_uuid$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_salt",
    "arguments": "text, integer",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text, integer)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "gen_salt",
    "arguments": "text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.gen_salt(text)\n RETURNS text\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_gen_salt$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_cron_access",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_cron'\n  )\n  THEN\n    grant usage on schema cron to postgres with grant option;\n\n    alter default privileges in schema cron grant all on tables to postgres with grant option;\n    alter default privileges in schema cron grant all on functions to postgres with grant option;\n    alter default privileges in schema cron grant all on sequences to postgres with grant option;\n\n    alter default privileges for user supabase_admin in schema cron grant all\n        on sequences to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on tables to postgres with grant option;\n    alter default privileges for user supabase_admin in schema cron grant all\n        on functions to postgres with grant option;\n\n    grant all privileges on all tables in schema cron to postgres with grant option;\n    revoke all on table cron.job from postgres;\n    grant select on table cron.job to postgres with grant option;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_graphql_access",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_graphql_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    func_is_graphql_resolve bool;\nBEGIN\n    func_is_graphql_resolve = (\n        SELECT n.proname = 'resolve'\n        FROM pg_event_trigger_ddl_commands() AS ev\n        LEFT JOIN pg_catalog.pg_proc AS n\n        ON ev.objid = n.oid\n    );\n\n    IF func_is_graphql_resolve\n    THEN\n        -- Update public wrapper to pass all arguments through to the pg_graphql resolve func\n        DROP FUNCTION IF EXISTS graphql_public.graphql;\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language sql\n        as $$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $$;\n\n        -- This hook executes when `graphql.resolve` is created. That is not necessarily the last\n        -- function in the extension so we need to grant permissions on existing entities AND\n        -- update default permissions to any others that are created after `graphql.resolve`\n        grant usage on schema graphql to postgres, anon, authenticated, service_role;\n        grant select on all tables in schema graphql to postgres, anon, authenticated, service_role;\n        grant execute on all functions in schema graphql to postgres, anon, authenticated, service_role;\n        grant all on all sequences in schema graphql to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on tables to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on functions to postgres, anon, authenticated, service_role;\n        alter default privileges in schema graphql grant all on sequences to postgres, anon, authenticated, service_role;\n\n        -- Allow postgres role to allow granting usage on graphql and graphql_public schemas to custom roles\n        grant usage on schema graphql_public to postgres with grant option;\n        grant usage on schema graphql to postgres with grant option;\n    END IF;\n\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "grant_pg_net_access",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_event_trigger_ddl_commands() AS ev\n    JOIN pg_extension AS ext\n    ON ev.objid = ext.oid\n    WHERE ext.extname = 'pg_net'\n  )\n  THEN\n    IF NOT EXISTS (\n      SELECT 1\n      FROM pg_roles\n      WHERE rolname = 'supabase_functions_admin'\n    )\n    THEN\n      CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;\n    END IF;\n\n    GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n\n    IF EXISTS (\n      SELECT FROM pg_extension\n      WHERE extname = 'pg_net'\n      -- all versions in use on existing projects as of 2025-02-20\n      -- version 0.12.0 onwards don't need these applied\n      AND extversion IN ('0.2', '0.6', '0.7', '0.7.1', '0.8', '0.10.0', '0.11.0')\n    ) THEN\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;\n\n      ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n      ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;\n\n      REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n      REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;\n\n      GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n      GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;\n    END IF;\n  END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "hmac",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(text, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "hmac",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.hmac(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pg_hmac$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements",
    "arguments": "showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone",
    "return_type": "SETOF record",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements(showtext boolean, OUT userid oid, OUT dbid oid, OUT toplevel boolean, OUT queryid bigint, OUT query text, OUT plans bigint, OUT total_plan_time double precision, OUT min_plan_time double precision, OUT max_plan_time double precision, OUT mean_plan_time double precision, OUT stddev_plan_time double precision, OUT calls bigint, OUT total_exec_time double precision, OUT min_exec_time double precision, OUT max_exec_time double precision, OUT mean_exec_time double precision, OUT stddev_exec_time double precision, OUT rows bigint, OUT shared_blks_hit bigint, OUT shared_blks_read bigint, OUT shared_blks_dirtied bigint, OUT shared_blks_written bigint, OUT local_blks_hit bigint, OUT local_blks_read bigint, OUT local_blks_dirtied bigint, OUT local_blks_written bigint, OUT temp_blks_read bigint, OUT temp_blks_written bigint, OUT shared_blk_read_time double precision, OUT shared_blk_write_time double precision, OUT local_blk_read_time double precision, OUT local_blk_write_time double precision, OUT temp_blk_read_time double precision, OUT temp_blk_write_time double precision, OUT wal_records bigint, OUT wal_fpi bigint, OUT wal_bytes numeric, OUT jit_functions bigint, OUT jit_generation_time double precision, OUT jit_inlining_count bigint, OUT jit_inlining_time double precision, OUT jit_optimization_count bigint, OUT jit_optimization_time double precision, OUT jit_emission_count bigint, OUT jit_emission_time double precision, OUT jit_deform_count bigint, OUT jit_deform_time double precision, OUT stats_since timestamp with time zone, OUT minmax_stats_since timestamp with time zone)\n RETURNS SETOF record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_1_11$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements_info",
    "arguments": "OUT dealloc bigint, OUT stats_reset timestamp with time zone",
    "return_type": "record",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_info(OUT dealloc bigint, OUT stats_reset timestamp with time zone)\n RETURNS record\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_info$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pg_stat_statements_reset",
    "arguments": "userid oid, dbid oid, queryid bigint, minmax_only boolean",
    "return_type": "timestamp with time zone",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pg_stat_statements_reset(userid oid DEFAULT 0, dbid oid DEFAULT 0, queryid bigint DEFAULT 0, minmax_only boolean DEFAULT false)\n RETURNS timestamp with time zone\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pg_stat_statements', $function$pg_stat_statements_reset_1_11$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_armor_headers",
    "arguments": "text, OUT key text, OUT value text",
    "return_type": "SETOF record",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_armor_headers(text, OUT key text, OUT value text)\n RETURNS SETOF record\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_armor_headers$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_key_id",
    "arguments": "bytea",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_key_id(bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_key_id_w$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text, text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea, text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt",
    "arguments": "bytea, bytea",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt(bytea, bytea)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_decrypt_bytea",
    "arguments": "bytea, bytea, text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_decrypt_bytea(bytea, bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "arguments": "text, bytea",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt",
    "arguments": "text, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt(text, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_pub_encrypt_bytea",
    "arguments": "bytea, bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_pub_encrypt_bytea(bytea, bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "arguments": "bytea, text, text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt",
    "arguments": "bytea, text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt(bytea, text)\n RETURNS text\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_decrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_decrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "arguments": "text, text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt",
    "arguments": "text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt(text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgp_sym_encrypt_bytea",
    "arguments": "bytea, text",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgp_sym_encrypt_bytea(bytea, text)\n RETURNS bytea\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgrst_ddl_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_ddl_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  cmd record;\nBEGIN\n  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()\n  LOOP\n    IF cmd.command_tag IN (\n      'CREATE SCHEMA', 'ALTER SCHEMA'\n    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'\n    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'\n    , 'CREATE VIEW', 'ALTER VIEW'\n    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'\n    , 'CREATE FUNCTION', 'ALTER FUNCTION'\n    , 'CREATE TRIGGER'\n    , 'CREATE TYPE', 'ALTER TYPE'\n    , 'CREATE RULE'\n    , 'COMMENT'\n    )\n    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp\n    AND cmd.schema_name is distinct from 'pg_temp'\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "pgrst_drop_watch",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.pgrst_drop_watch()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  obj record;\nBEGIN\n  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n  LOOP\n    IF obj.object_type IN (\n      'schema'\n    , 'table'\n    , 'foreign table'\n    , 'view'\n    , 'materialized view'\n    , 'function'\n    , 'trigger'\n    , 'type'\n    , 'rule'\n    )\n    AND obj.is_temporary IS false -- no pg_temp objects\n    THEN\n      NOTIFY pgrst, 'reload schema';\n    END IF;\n  END LOOP;\nEND; $function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "set_graphql_placeholder",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION extensions.set_graphql_placeholder()\n RETURNS event_trigger\n LANGUAGE plpgsql\nAS $function$\n    DECLARE\n    graphql_is_dropped bool;\n    BEGIN\n    graphql_is_dropped = (\n        SELECT ev.schema_name = 'graphql_public'\n        FROM pg_event_trigger_dropped_objects() AS ev\n        WHERE ev.schema_name = 'graphql_public'\n    );\n\n    IF graphql_is_dropped\n    THEN\n        create or replace function graphql_public.graphql(\n            \"operationName\" text default null,\n            query text default null,\n            variables jsonb default null,\n            extensions jsonb default null\n        )\n            returns jsonb\n            language plpgsql\n        as $$\n            DECLARE\n                server_version float;\n            BEGIN\n                server_version = (SELECT (SPLIT_PART((select version()), ' ', 2))::float);\n\n                IF server_version >= 14 THEN\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql extension is not enabled.'\n                            )\n                        )\n                    );\n                ELSE\n                    RETURN jsonb_build_object(\n                        'errors', jsonb_build_array(\n                            jsonb_build_object(\n                                'message', 'pg_graphql is only available on projects running Postgres 14 onwards.'\n                            )\n                        )\n                    );\n                END IF;\n            END;\n        $$;\n    END IF;\n\n    END;\n$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v1",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v1mc",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v1mc()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v3",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v3(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v4",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v4()\n RETURNS uuid\n LANGUAGE c\n PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_generate_v5",
    "arguments": "namespace uuid, name text",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_generate_v5(namespace uuid, name text)\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_nil",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_nil()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_nil$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_dns",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_dns()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_oid",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_oid()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_url",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_url()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_url$function$\n"
  },
  {
    "schema": "extensions",
    "function_name": "uuid_ns_x500",
    "arguments": "",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION extensions.uuid_ns_x500()\n RETURNS uuid\n LANGUAGE c\n IMMUTABLE PARALLEL SAFE STRICT\nAS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "_internal_resolve",
    "arguments": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION graphql._internal_resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE c\nAS '$libdir/pg_graphql', $function$resolve_wrapper$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "comment_directive",
    "arguments": "comment_ text",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION graphql.comment_directive(comment_ text)\n RETURNS jsonb\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    comment on column public.account.name is '@graphql.name: myField'\n    */\n    select\n        coalesce(\n            (\n                regexp_match(\n                    comment_,\n                    '@graphql\\((.+)\\)'\n                )\n            )[1]::jsonb,\n            jsonb_build_object()\n        )\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "exception",
    "arguments": "message text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION graphql.exception(message text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nbegin\n    raise exception using errcode='22000', message=message;\nend;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "get_schema_version",
    "arguments": "",
    "return_type": "integer",
    "definition": "CREATE OR REPLACE FUNCTION graphql.get_schema_version()\n RETURNS integer\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n    select last_value from graphql.seq_schema_version;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "increment_schema_version",
    "arguments": "",
    "return_type": "event_trigger",
    "definition": "CREATE OR REPLACE FUNCTION graphql.increment_schema_version()\n RETURNS event_trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    perform pg_catalog.nextval('graphql.seq_schema_version');\nend;\n$function$\n"
  },
  {
    "schema": "graphql",
    "function_name": "resolve",
    "arguments": "query text, variables jsonb, \"operationName\" text, extensions jsonb",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION graphql.resolve(query text, variables jsonb DEFAULT '{}'::jsonb, \"operationName\" text DEFAULT NULL::text, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    res jsonb;\n    message_text text;\nbegin\n  begin\n    select graphql._internal_resolve(\"query\" := \"query\",\n                                     \"variables\" := \"variables\",\n                                     \"operationName\" := \"operationName\",\n                                     \"extensions\" := \"extensions\") into res;\n    return res;\n  exception\n    when others then\n    get stacked diagnostics message_text = message_text;\n    return\n    jsonb_build_object('data', null,\n                       'errors', jsonb_build_array(jsonb_build_object('message', message_text)));\n  end;\nend;\n$function$\n"
  },
  {
    "schema": "graphql_public",
    "function_name": "graphql",
    "arguments": "\"operationName\" text, query text, variables jsonb, extensions jsonb",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION graphql_public.graphql(\"operationName\" text DEFAULT NULL::text, query text DEFAULT NULL::text, variables jsonb DEFAULT NULL::jsonb, extensions jsonb DEFAULT NULL::jsonb)\n RETURNS jsonb\n LANGUAGE sql\nAS $function$\n            select graphql.resolve(\n                query := query,\n                variables := coalesce(variables, '{}'),\n                \"operationName\" := \"operationName\",\n                extensions := extensions\n            );\n        $function$\n"
  },
  {
    "schema": "pgbouncer",
    "function_name": "get_auth",
    "arguments": "p_usename text",
    "return_type": "TABLE(username text, password text)",
    "definition": "CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename text)\n RETURNS TABLE(username text, password text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n    raise debug 'PgBouncer auth request: %', p_usename;\n\n    return query\n    select \n        rolname::text, \n        case when rolvaliduntil < now() \n            then null \n            else rolpassword::text \n        end \n    from pg_authid \n    where rolname=$1 and rolcanlogin;\nend;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "activate_user",
    "arguments": "p_user_id integer",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.activate_user(p_user_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update user availability\n    UPDATE users SET availability = 'available' WHERE user_id = p_user_id;\n    \n    RETURN json_build_object('message', 'User ' || p_user_id || ' activated successfully');\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "add_group_member",
    "arguments": "p_group_id integer, p_user_id integer, p_role text",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.add_group_member(p_group_id integer, p_user_id integer, p_role text DEFAULT 'member'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if group exists\n    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users u WHERE u.user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user is already a member\n    IF EXISTS (SELECT 1 FROM group_participants WHERE group_id = p_group_id AND user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User % is already a member of group %', p_user_id, p_group_id USING ERRCODE = '23505';\n    END IF;\n    \n    -- Validate role\n    IF p_role NOT IN ('admin', 'member', 'mentor') THEN\n        RAISE EXCEPTION 'Invalid role. Must be admin, member, or mentor' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Add user to group\n    INSERT INTO group_participants (group_id, user_id, role)\n    VALUES (p_group_id, p_user_id, p_role);\n    \n    RETURN json_build_object('message', 'User ' || p_user_id || ' added to group ' || p_group_id);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "add_paper_to_session",
    "arguments": "p_session_id integer, p_paper_id integer",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.add_paper_to_session(p_session_id integer, p_paper_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if paper exists\n    IF NOT EXISTS (SELECT 1 FROM papers WHERE paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper with ID % not found', p_paper_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if paper is already in session\n    IF EXISTS (SELECT 1 FROM session_papers WHERE session_id = p_session_id AND paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper % is already in session %', p_paper_id, p_session_id USING ERRCODE = '23505';\n    END IF;\n    \n    -- Add paper to session\n    INSERT INTO session_papers (session_id, paper_id)\n    VALUES (p_session_id, p_paper_id);\n    \n    RETURN json_build_object('message', 'Paper ' || p_paper_id || ' added to session ' || p_session_id);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "add_session_participant",
    "arguments": "p_session_id integer, p_user_id integer",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.add_session_participant(p_session_id integer, p_user_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user is already a participant\n    IF EXISTS (SELECT 1 FROM session_participants WHERE session_id = p_session_id AND user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User % is already a participant in session %', p_user_id, p_session_id USING ERRCODE = '23505';\n    END IF;\n    \n    -- Add user to session\n    INSERT INTO session_participants (session_id, user_id)\n    VALUES (p_session_id, p_user_id);\n    \n    RETURN json_build_object('message', 'User ' || p_user_id || ' added to session ' || p_session_id);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "can_user_invoke_ai",
    "arguments": "p_user_id integer, p_session_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.can_user_invoke_ai(p_user_id integer, p_session_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_role VARCHAR(50);\n    v_is_session_creator BOOLEAN;\nBEGIN\n    -- Get user's role in the group\n    SELECT gp.role INTO v_user_role\n    FROM sessions s\n    JOIN group_participants gp ON s.group_id = gp.group_id\n    WHERE s.session_id = p_session_id\n    AND gp.user_id = p_user_id;\n    \n    -- Check if user is the session creator\n    SELECT (created_by = p_user_id) INTO v_is_session_creator\n    FROM sessions\n    WHERE session_id = p_session_id;\n    \n    -- Allow AI invocation if user is admin, mentor, or session creator\n    RETURN (v_user_role IN ('admin', 'mentor') OR v_is_session_creator);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "check_group_creation_permissions",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.check_group_creation_permissions()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    IF NEW.created_by < 2 THEN\n        RAISE EXCEPTION 'Users with ID less than 2 are not allowed to create groups';\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "cleanup_old_presence",
    "arguments": "",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.cleanup_old_presence()\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    DELETE FROM user_presence \n    WHERE status = 'offline' \n    AND last_seen < (CURRENT_TIMESTAMP - INTERVAL '1 hour');\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_ai_metadata",
    "arguments": "p_message_id integer, p_paper_id integer, p_page_no integer",
    "return_type": "TABLE(id integer, message_id integer, paper_id integer, page_no integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_ai_metadata(p_message_id integer, p_paper_id integer, p_page_no integer DEFAULT NULL::integer)\n RETURNS TABLE(id integer, message_id integer, paper_id integer, page_no integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_id INTEGER;\nBEGIN\n    -- Check if message exists\n    IF NOT EXISTS (SELECT 1 FROM messages WHERE message_id = p_message_id) THEN\n        RAISE EXCEPTION 'Message with ID % not found', p_message_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if paper exists\n    IF NOT EXISTS (SELECT 1 FROM papers WHERE paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper with ID % not found', p_paper_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert AI metadata\n    INSERT INTO ai_metadata (message_id, paper_id, page_no)\n    VALUES (p_message_id, p_paper_id, p_page_no)\n    RETURNING id INTO v_id;\n    \n    -- Return the created metadata\n    RETURN QUERY\n    SELECT \n        v_id as id,\n        p_message_id as message_id,\n        p_paper_id as paper_id,\n        p_page_no as page_no,\n        CURRENT_TIMESTAMP as created_at;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_feedback",
    "arguments": "p_session_id integer, p_user_id integer, p_content text, p_rating integer",
    "return_type": "TABLE(feedback_id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_feedback(p_session_id integer, p_user_id integer, p_content text, p_rating integer DEFAULT NULL::integer)\n RETURNS TABLE(feedback_id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_feedback_id INTEGER;\n    v_group_id INTEGER;\n    v_participant_id INTEGER;\nBEGIN\n    -- Validate inputs\n    IF p_content IS NULL OR trim(p_content) = '' THEN\n        RAISE EXCEPTION 'Feedback content is required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Validate rating if provided\n    IF p_rating IS NOT NULL AND (p_rating < 1 OR p_rating > 5) THEN\n        RAISE EXCEPTION 'Rating must be between 1 and 5' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if session exists and get group_id\n    SELECT s.group_id INTO v_group_id\n    FROM sessions s\n    WHERE s.session_id = p_session_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get user's group participant ID\n    SELECT gp.group_participant_id INTO v_participant_id\n    FROM group_participants gp\n    WHERE gp.group_id = v_group_id AND gp.user_id = p_user_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'User % is not a member of the session group', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert feedback\n    INSERT INTO feedback (session_id, given_by, content, rating)\n    VALUES (p_session_id, v_participant_id, p_content, p_rating)\n    RETURNING feedback_id INTO v_feedback_id;\n    \n    -- Return the created feedback\n    RETURN QUERY\n    SELECT \n        v_feedback_id as feedback_id,\n        p_session_id as session_id,\n        p_user_id as given_by,\n        p_content as content,\n        p_rating as rating,\n        CURRENT_TIMESTAMP as created_at;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_group",
    "arguments": "p_name text, p_created_by integer, p_description text, p_is_public boolean",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.create_group(p_name text, p_created_by integer, p_description text DEFAULT ''::text, p_is_public boolean DEFAULT false)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_group_id INTEGER;\n    v_invite_code VARCHAR(12);\n    result JSON;\nBEGIN\n    -- Check if created_by is allowed to create groups\n    IF p_created_by < 2 THEN\n        RAISE EXCEPTION 'Users with ID less than 2 are not allowed to create groups';\n    END IF;\n    \n    -- Validate group name\n    IF p_name IS NULL OR trim(p_name) = '' THEN\n        RAISE EXCEPTION 'Group name is required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_created_by) THEN\n        RAISE EXCEPTION 'Creator user with ID % not found', p_created_by USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert new group (invite_code will be auto-generated by trigger)\n    INSERT INTO groups (name, description, created_by, is_public, created_at)\n    VALUES (p_name, p_description, p_created_by, p_is_public, NOW())\n    RETURNING group_id, invite_code INTO v_group_id, v_invite_code;\n    \n    -- Add creator as admin member\n    INSERT INTO group_participants (group_id, user_id, role, joined_at)\n    VALUES (v_group_id, p_created_by, 'admin', NOW());\n    \n    -- Return success result with group details including invite_code\n    SELECT json_build_object(\n        'success', true,\n        'group_id', v_group_id,\n        'name', p_name,\n        'description', p_description,\n        'is_public', p_is_public,\n        'invite_code', v_invite_code,\n        'created_by', p_created_by,\n        'created_at', NOW()\n    ) INTO result;\n    \n    RETURN result;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to create group: %', SQLERRM;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_group_chat_session",
    "arguments": "p_group_id integer, p_created_by integer, p_title text, p_description text",
    "return_type": "TABLE(session_id integer, title text, description text, status character varying, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_group_chat_session(p_group_id integer, p_created_by integer, p_title text DEFAULT 'Group Chat Session'::text, p_description text DEFAULT ''::text)\n RETURNS TABLE(session_id integer, title text, description text, status character varying, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_session_id INTEGER;\nBEGIN\n    -- Validate inputs\n    IF p_group_id IS NULL OR p_created_by IS NULL THEN\n        RAISE EXCEPTION 'Group ID and Creator ID are required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if user is a member of the group\n    IF NOT EXISTS (\n        SELECT 1 FROM group_participants \n        WHERE group_id = p_group_id AND user_id = p_created_by\n    ) THEN\n        RAISE EXCEPTION 'User is not a member of this group' USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Create new session (use topic instead of title, no description column)\n    INSERT INTO sessions (group_id, topic, created_by, status)\n    VALUES (p_group_id, p_title, p_created_by, 'active')\n    RETURNING sessions.session_id INTO v_session_id;\n    \n    -- Add creator as participant\n    INSERT INTO session_participants (session_id, user_id)\n    VALUES (v_session_id, p_created_by);\n    \n    -- Return session details with proper type casting\n    RETURN QUERY\n    SELECT \n        v_session_id,\n        p_title,\n        p_description,\n        'active'::VARCHAR(20),\n        CURRENT_TIMESTAMP::TIMESTAMP  -- Simple cast to remove timezone\n    ;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_group_chat_session",
    "arguments": "p_group_id integer, p_created_by integer, p_topic text",
    "return_type": "TABLE(session_id integer, topic text, status character varying, started_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_group_chat_session(p_group_id integer, p_created_by integer, p_topic text DEFAULT 'Group Chat Session'::text)\n RETURNS TABLE(session_id integer, topic text, status character varying, started_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_session_id INTEGER;\n    v_started_at TIMESTAMP;\nBEGIN\n    -- Validate inputs\n    IF p_group_id IS NULL OR p_created_by IS NULL THEN\n        RAISE EXCEPTION 'Group ID and Creator ID are required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if user is a member of the group\n    IF NOT EXISTS (\n        SELECT 1 FROM group_participants \n        WHERE group_id = p_group_id AND user_id = p_created_by\n    ) THEN\n        RAISE EXCEPTION 'User is not a member of this group' USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Create new session with actual table columns\n    INSERT INTO sessions (group_id, topic, created_by, status, started_at)\n    VALUES (p_group_id, p_topic, p_created_by, 'active', CURRENT_TIMESTAMP)\n    RETURNING sessions.session_id, sessions.started_at INTO v_session_id, v_started_at;\n    \n    -- Add creator as participant\n    INSERT INTO session_participants (session_id, user_id)\n    VALUES (v_session_id, p_created_by);\n    \n    -- Return session details with actual column names\n    RETURN QUERY\n    SELECT \n        v_session_id,\n        p_topic,\n        'active'::VARCHAR(50),\n        v_started_at;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_message",
    "arguments": "p_session_id integer, p_sender_user_id integer, p_content text",
    "return_type": "TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_message(p_session_id integer, p_sender_user_id integer, p_content text)\n RETURNS TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_sender_participant_id INTEGER;\n    v_message_id INTEGER;\n    v_group_id INTEGER;\nBEGIN\n    -- Validate inputs\n    IF p_content IS NULL OR trim(p_content) = '' THEN\n        RAISE EXCEPTION 'Message content is required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if session exists and get group_id\n    SELECT s.group_id INTO v_group_id\n    FROM sessions s\n    WHERE s.session_id = p_session_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get sender's group participant ID\n    SELECT gp.group_participant_id INTO v_sender_participant_id\n    FROM group_participants gp\n    WHERE gp.group_id = v_group_id AND gp.user_id = p_sender_user_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'User % is not a member of the session group', p_sender_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert new message\n    INSERT INTO messages (session_id, sender_id, content, sent_at)\n    VALUES (p_session_id, v_sender_participant_id, p_content, CURRENT_TIMESTAMP)\n    RETURNING message_id INTO v_message_id;\n    \n    -- Return the created message\n    RETURN QUERY\n    SELECT \n        v_message_id as message_id,\n        p_session_id as session_id,\n        p_sender_user_id as sender_id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as sender_name,\n        p_content as content,\n        CURRENT_TIMESTAMP as sent_at\n    FROM users u\n    WHERE u.user_id = p_sender_user_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_paper",
    "arguments": "p_title text, p_abstract text, p_authors text, p_doi text, p_published_at timestamp without time zone, p_source_url text, p_tags text[]",
    "return_type": "TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_paper(p_title text, p_abstract text DEFAULT NULL::text, p_authors text DEFAULT NULL::text, p_doi text DEFAULT NULL::text, p_published_at timestamp without time zone DEFAULT NULL::timestamp without time zone, p_source_url text DEFAULT NULL::text, p_tags text[] DEFAULT NULL::text[])\n RETURNS TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_paper_id INTEGER;\n    tag_item TEXT;\nBEGIN\n    -- Validate title is not empty\n    IF p_title IS NULL OR trim(p_title) = '' THEN\n        RAISE EXCEPTION 'Paper title is required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if paper with same DOI already exists (if DOI provided)\n    IF p_doi IS NOT NULL AND EXISTS (SELECT 1 FROM papers WHERE doi = p_doi) THEN\n        RAISE EXCEPTION 'Paper with DOI % already exists', p_doi USING ERRCODE = '23505';\n    END IF;\n    \n    -- Insert new paper\n    INSERT INTO papers (title, abstract, authors, doi, published_at, source_url)\n    VALUES (p_title, p_abstract, p_authors, p_doi, p_published_at, p_source_url)\n    RETURNING paper_id INTO v_paper_id;\n    \n    -- Add tags if provided\n    IF p_tags IS NOT NULL THEN\n        FOREACH tag_item IN ARRAY p_tags\n        LOOP\n            INSERT INTO paper_tags (paper_id, tag)\n            VALUES (v_paper_id, tag_item)\n            ON CONFLICT DO NOTHING;\n        END LOOP;\n    END IF;\n    \n    -- Return the created paper\n    RETURN QUERY\n    SELECT \n        v_paper_id as paper_id,\n        p_title as title,\n        p_abstract as abstract,\n        p_authors as authors,\n        p_doi as doi,\n        p_published_at as published_at,\n        p_source_url as source_url,\n        CURRENT_TIMESTAMP as created_at;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_session",
    "arguments": "p_group_id integer, p_created_by integer, p_topic text, p_status character varying",
    "return_type": "TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_session(p_group_id integer, p_created_by integer, p_topic text DEFAULT NULL::text, p_status character varying DEFAULT 'active'::character varying)\n RETURNS TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_session_id INTEGER;\nBEGIN\n    -- Validate that group exists\n    IF NOT EXISTS (SELECT 1 FROM groups WHERE group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Validate that user exists and is member of group\n    IF NOT EXISTS (\n        SELECT 1 FROM group_participants gp \n        WHERE gp.group_id = p_group_id AND gp.user_id = p_created_by\n    ) THEN\n        RAISE EXCEPTION 'User % is not a member of group %', p_created_by, p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert new session\n    INSERT INTO sessions (group_id, created_by, topic, status, started_at)\n    VALUES (p_group_id, p_created_by, p_topic, p_status, CURRENT_TIMESTAMP)\n    RETURNING session_id INTO v_session_id;\n    \n    -- Add creator as participant\n    INSERT INTO session_participants (session_id, user_id)\n    VALUES (v_session_id, p_created_by)\n    ON CONFLICT (session_id, user_id) DO NOTHING;\n    \n    -- Return created session\n    RETURN QUERY\n    SELECT \n        v_session_id as id,\n        COALESCE(p_topic, 'Untitled Session') as title,\n        ''::TEXT as description,\n        p_created_by as created_by,\n        p_group_id as group_id,\n        CURRENT_TIMESTAMP as created_at,\n        CURRENT_TIMESTAMP as started_at,\n        NULL::TIMESTAMP as ended_at,\n        p_status as status,\n        1::BIGINT as participant_count;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_session",
    "arguments": "p_title text, p_user_id integer, p_group_id integer",
    "return_type": "TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status text, participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_session(p_title text, p_user_id integer, p_group_id integer DEFAULT 1)\n RETURNS TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status text, participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_session_id INTEGER;\n    v_final_title TEXT;\nBEGIN\n    -- Validate user exists\n    IF NOT EXISTS (SELECT 1 FROM users u WHERE u.user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Validate group exists\n    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Set default title if not provided\n    v_final_title := COALESCE(p_title, 'Session ' || TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS'));\n    \n    -- Insert new session\n    INSERT INTO sessions (group_id, created_by, topic, status, started_at)\n    VALUES (p_group_id, p_user_id, v_final_title, 'active', CURRENT_TIMESTAMP)\n    RETURNING session_id INTO v_session_id;\n    \n    -- Ensure user is a participant in the group\n    INSERT INTO group_participants (group_id, user_id, role)\n    VALUES (p_group_id, p_user_id, 'member')\n    ON CONFLICT ON CONSTRAINT group_participants_group_id_user_id_key DO NOTHING;\n    \n    -- Return the created session\n    RETURN QUERY\n    SELECT \n        v_session_id as id,\n        v_final_title as title,\n        ''::TEXT as description,\n        p_user_id as created_by,\n        p_group_id as group_id,\n        CURRENT_TIMESTAMP as created_at,\n        CURRENT_TIMESTAMP as started_at,\n        null::timestamp as ended_at,\n        'active'::TEXT as status,\n        0::BIGINT as participant_count;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "create_user",
    "arguments": "p_email text, p_first_name text, p_last_name text",
    "return_type": "TABLE(id integer, name text, email text, is_active boolean)",
    "definition": "CREATE OR REPLACE FUNCTION public.create_user(p_email text, p_first_name text DEFAULT NULL::text, p_last_name text DEFAULT NULL::text)\n RETURNS TABLE(id integer, name text, email text, is_active boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_user_id INTEGER;\nBEGIN\n    -- Validate email is not empty\n    IF p_email IS NULL OR trim(p_email) = '' THEN\n        RAISE EXCEPTION 'Email is required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if user with email already exists\n    IF EXISTS (SELECT 1 FROM users WHERE email = p_email) THEN\n        RAISE EXCEPTION 'User with email % already exists', p_email USING ERRCODE = '23505';\n    END IF;\n    \n    -- Insert new user\n    INSERT INTO users (email, first_name, last_name, availability)\n    VALUES (p_email, p_first_name, p_last_name, 'available')\n    RETURNING user_id INTO v_user_id;\n    \n    -- Return the created user\n    RETURN QUERY\n    SELECT \n        v_user_id as id,\n        COALESCE(\n            TRIM(CONCAT(p_first_name, ' ', p_last_name)), \n            p_email\n        ) as name,\n        p_email as email,\n        true as is_active;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "current_user_id",
    "arguments": "",
    "return_type": "integer",
    "definition": "CREATE OR REPLACE FUNCTION public.current_user_id()\n RETURNS integer\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\nAS $function$\n        DECLARE\n          user_id_result INTEGER;\n        BEGIN\n          SELECT user_id INTO user_id_result\n          FROM public.users \n          WHERE auth_user_id = auth.uid();\n          \n          RETURN user_id_result;\n        END;\n        $function$\n"
  },
  {
    "schema": "public",
    "function_name": "deactivate_user",
    "arguments": "p_user_id integer",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.deactivate_user(p_user_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update user availability\n    UPDATE users SET availability = 'offline' WHERE user_id = p_user_id;\n    \n    RETURN json_build_object('message', 'User ' || p_user_id || ' deactivated successfully');\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_ai_metadata",
    "arguments": "p_ai_metadata_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_ai_metadata(p_ai_metadata_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if AI metadata exists\n    IF NOT EXISTS (SELECT 1 FROM ai_metadata WHERE ai_metadata_id = p_ai_metadata_id) THEN\n        RAISE EXCEPTION 'AI metadata with ID % not found', p_ai_metadata_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete AI metadata\n    DELETE FROM ai_metadata WHERE ai_metadata_id = p_ai_metadata_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_feedback",
    "arguments": "p_feedback_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_feedback(p_feedback_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if feedback exists\n    IF NOT EXISTS (SELECT 1 FROM feedback WHERE feedback_id = p_feedback_id) THEN\n        RAISE EXCEPTION 'Feedback with ID % not found', p_feedback_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete feedback\n    DELETE FROM feedback WHERE feedback_id = p_feedback_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_message",
    "arguments": "p_message_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_message(p_message_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if message exists\n    IF NOT EXISTS (SELECT 1 FROM messages WHERE message_id = p_message_id) THEN\n        RAISE EXCEPTION 'Message with ID % not found', p_message_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete message (cascading deletes will handle related records)\n    DELETE FROM messages WHERE message_id = p_message_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_paper",
    "arguments": "p_paper_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_paper(p_paper_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if paper exists\n    IF NOT EXISTS (SELECT 1 FROM papers WHERE paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper with ID % not found', p_paper_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete paper (cascading deletes will handle related records)\n    DELETE FROM papers WHERE paper_id = p_paper_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_session",
    "arguments": "p_session_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_session(p_session_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete session (cascading deletes will handle related records)\n    DELETE FROM sessions WHERE session_id = p_session_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "delete_user",
    "arguments": "p_user_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.delete_user(p_user_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Delete user (cascading deletes will handle related records)\n    DELETE FROM users WHERE user_id = p_user_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "generate_invite_code",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION public.generate_invite_code()\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    chars TEXT := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    result TEXT := '';\n    i INTEGER := 0;\nBEGIN\n    FOR i IN 1..8 LOOP\n        result := result || substr(chars, floor(random() * length(chars) + 1)::INTEGER, 1);\n    END LOOP;\n    RETURN result;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_ai_metadata_by_id",
    "arguments": "p_ai_metadata_id integer",
    "return_type": "TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_ai_metadata_by_id(p_ai_metadata_id integer)\n RETURNS TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.ai_metadata_id::INTEGER as id,\n        am.message_id::INTEGER as message_id,\n        am.model_name,\n        am.input_tokens::INTEGER as input_tokens,\n        am.output_tokens::INTEGER as output_tokens,\n        am.cost,\n        am.processing_time,\n        am.created_at\n    FROM ai_metadata am\n    WHERE am.ai_metadata_id = p_ai_metadata_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'AI metadata with ID % not found', p_ai_metadata_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_ai_metadata_by_message",
    "arguments": "p_message_id integer",
    "return_type": "TABLE(id integer, message_id integer, paper_id integer, paper_title text, page_no integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_ai_metadata_by_message(p_message_id integer)\n RETURNS TABLE(id integer, message_id integer, paper_id integer, paper_title text, page_no integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.id::INTEGER,\n        am.message_id::INTEGER,\n        am.paper_id::INTEGER,\n        p.title as paper_title,\n        am.page_no,\n        am.created_at\n    FROM ai_metadata am\n    JOIN papers p ON am.paper_id = p.paper_id\n    WHERE am.message_id = p_message_id\n    ORDER BY am.created_at ASC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_ai_metadata_by_model",
    "arguments": "p_model_name text, p_limit integer",
    "return_type": "TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_ai_metadata_by_model(p_model_name text, p_limit integer DEFAULT 100)\n RETURNS TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.ai_metadata_id::INTEGER as id,\n        am.message_id::INTEGER as message_id,\n        am.model_name,\n        am.input_tokens::INTEGER as input_tokens,\n        am.output_tokens::INTEGER as output_tokens,\n        am.cost,\n        am.processing_time,\n        am.created_at\n    FROM ai_metadata am\n    WHERE am.model_name = p_model_name\n    ORDER BY am.created_at DESC\n    LIMIT p_limit;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_ai_performance_stats",
    "arguments": "p_model_name text",
    "return_type": "TABLE(model_name text, total_requests bigint, average_input_tokens numeric, average_output_tokens numeric, average_cost numeric, average_processing_time numeric, min_processing_time numeric, max_processing_time numeric)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_ai_performance_stats(p_model_name text DEFAULT NULL::text)\n RETURNS TABLE(model_name text, total_requests bigint, average_input_tokens numeric, average_output_tokens numeric, average_cost numeric, average_processing_time numeric, min_processing_time numeric, max_processing_time numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.model_name,\n        COUNT(*) as total_requests,\n        AVG(am.input_tokens) as average_input_tokens,\n        AVG(am.output_tokens) as average_output_tokens,\n        AVG(am.cost) as average_cost,\n        AVG(am.processing_time) as average_processing_time,\n        MIN(am.processing_time) as min_processing_time,\n        MAX(am.processing_time) as max_processing_time\n    FROM ai_metadata am\n    WHERE (p_model_name IS NULL OR am.model_name = p_model_name)\n    GROUP BY am.model_name\n    ORDER BY total_requests DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_ai_usage_stats",
    "arguments": "p_date_from date, p_date_to date",
    "return_type": "TABLE(total_requests bigint, total_input_tokens bigint, total_output_tokens bigint, total_cost numeric, average_processing_time numeric, model_usage jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_ai_usage_stats(p_date_from date DEFAULT NULL::date, p_date_to date DEFAULT NULL::date)\n RETURNS TABLE(total_requests bigint, total_input_tokens bigint, total_output_tokens bigint, total_cost numeric, average_processing_time numeric, model_usage jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_total_requests BIGINT;\n    v_total_input BIGINT;\n    v_total_output BIGINT;\n    v_total_cost NUMERIC;\n    v_avg_time NUMERIC;\n    v_model_usage JSONB;\nBEGIN\n    -- Get overall stats\n    SELECT \n        COUNT(*),\n        SUM(input_tokens),\n        SUM(output_tokens),\n        SUM(cost),\n        AVG(processing_time)\n    INTO v_total_requests, v_total_input, v_total_output, v_total_cost, v_avg_time\n    FROM ai_metadata am\n    WHERE (p_date_from IS NULL OR am.created_at::date >= p_date_from)\n    AND (p_date_to IS NULL OR am.created_at::date <= p_date_to);\n    \n    -- Get model usage distribution\n    SELECT json_object_agg(model_name, usage_count) INTO v_model_usage\n    FROM (\n        SELECT model_name, COUNT(*) as usage_count\n        FROM ai_metadata am\n        WHERE (p_date_from IS NULL OR am.created_at::date >= p_date_from)\n        AND (p_date_to IS NULL OR am.created_at::date <= p_date_to)\n        GROUP BY model_name\n        ORDER BY usage_count DESC\n    ) model_counts;\n    \n    RETURN QUERY\n    SELECT \n        COALESCE(v_total_requests, 0),\n        COALESCE(v_total_input, 0),\n        COALESCE(v_total_output, 0),\n        COALESCE(v_total_cost, 0.0),\n        COALESCE(v_avg_time, 0.0),\n        COALESCE(v_model_usage, '{}'::jsonb);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_ai_metadata",
    "arguments": "p_limit integer, p_offset integer",
    "return_type": "TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_ai_metadata(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0)\n RETURNS TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.ai_metadata_id::INTEGER as id,\n        am.message_id::INTEGER as message_id,\n        am.model_name,\n        am.input_tokens::INTEGER as input_tokens,\n        am.output_tokens::INTEGER as output_tokens,\n        am.cost,\n        am.processing_time,\n        am.created_at\n    FROM ai_metadata am\n    ORDER BY am.created_at DESC\n    LIMIT p_limit OFFSET p_offset;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_feedback",
    "arguments": "p_limit integer, p_offset integer",
    "return_type": "TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_feedback(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0)\n RETURNS TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER as id,\n        f.session_id::INTEGER as session_id,\n        f.given_by::INTEGER as given_by,\n        f.content,\n        f.rating::INTEGER as rating,\n        f.created_at\n    FROM feedback f\n    ORDER BY f.created_at DESC\n    LIMIT p_limit OFFSET p_offset;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_groups",
    "arguments": "",
    "return_type": "TABLE(id integer, name text, description text, member_count bigint, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_groups()\n RETURNS TABLE(id integer, name text, description text, member_count bigint, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        g.group_id::INTEGER as id,\n        g.name,\n        COALESCE(g.description, '') as description,\n        COUNT(gp.user_id) as member_count,\n        g.created_at\n    FROM groups g\n    LEFT JOIN group_participants gp ON g.group_id = gp.group_id\n    GROUP BY g.group_id, g.name, g.description, g.created_at\n    ORDER BY g.group_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_messages",
    "arguments": "p_limit integer, p_offset integer",
    "return_type": "TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_messages(p_limit integer DEFAULT 100, p_offset integer DEFAULT 0)\n RETURNS TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        m.message_id::INTEGER as id,\n        m.session_id::INTEGER as session_id,\n        m.sender_id::INTEGER as sender_id,\n        m.content,\n        COALESCE(m.message_type, 'user') as message_type,\n        m.sent_at\n    FROM messages m\n    ORDER BY m.sent_at DESC\n    LIMIT p_limit OFFSET p_offset;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_papers",
    "arguments": "",
    "return_type": "TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_papers()\n RETURNS TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        p.published_at,\n        p.source_url,\n        p.created_at\n    FROM papers p\n    ORDER BY p.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_sessions",
    "arguments": "p_user_id integer, p_is_active boolean",
    "return_type": "TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_sessions(p_user_id integer DEFAULT NULL::integer, p_is_active boolean DEFAULT NULL::boolean)\n RETURNS TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        s.session_id::INTEGER as id,\n        COALESCE(s.topic, 'Untitled Session') as title,\n        ''::TEXT as description,\n        s.created_by::INTEGER as created_by,\n        s.group_id::INTEGER as group_id,\n        s.started_at as created_at,\n        s.started_at as started_at,\n        s.ended_at as ended_at,\n        s.status as status,  -- Removed unnecessary cast\n        COUNT(DISTINCT sp.user_id) as participant_count\n    FROM sessions s\n    LEFT JOIN session_participants sp ON s.session_id = sp.session_id\n    WHERE (p_user_id IS NULL OR s.created_by = p_user_id)\n      AND (p_is_active IS NULL OR \n           (p_is_active = true AND s.status = 'active') OR\n           (p_is_active = false AND s.status != 'active'))\n    GROUP BY s.session_id, s.topic, s.created_by, s.group_id, s.started_at, s.ended_at, s.status\n    ORDER BY s.session_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_all_users",
    "arguments": "",
    "return_type": "TABLE(id integer, auth_id uuid, name text, email text, is_active boolean)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_all_users()\n RETURNS TABLE(id integer, auth_id uuid, name text, email text, is_active boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        u.user_id::INTEGER as id,\n        u.auth_user_id as auth_id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as name,\n        u.email,\n        CASE WHEN u.availability = 'available' THEN true ELSE false END as is_active\n    FROM users u\n    ORDER BY u.user_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_feedback_by_id",
    "arguments": "p_feedback_id integer",
    "return_type": "TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_feedback_by_id(p_feedback_id integer)\n RETURNS TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER as id,\n        f.session_id::INTEGER as session_id,\n        f.given_by::INTEGER as given_by,\n        f.content,\n        f.rating::INTEGER as rating,\n        f.created_at\n    FROM feedback f\n    WHERE f.feedback_id = p_feedback_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Feedback with ID % not found', p_feedback_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_feedback_stats",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(total_feedback bigint, average_rating numeric, rating_distribution jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_feedback_stats(p_session_id integer DEFAULT NULL::integer)\n RETURNS TABLE(total_feedback bigint, average_rating numeric, rating_distribution jsonb)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_total BIGINT;\n    v_avg NUMERIC;\n    v_distribution JSONB;\nBEGIN\n    -- Get total feedback\n    SELECT COUNT(*) INTO v_total\n    FROM feedback f\n    WHERE (p_session_id IS NULL OR f.session_id = p_session_id);\n    \n    -- Get average rating\n    SELECT AVG(rating) INTO v_avg\n    FROM feedback f\n    WHERE (p_session_id IS NULL OR f.session_id = p_session_id)\n    AND rating IS NOT NULL;\n    \n    -- Get rating distribution\n    SELECT json_object_agg(rating, count) INTO v_distribution\n    FROM (\n        SELECT rating, COUNT(*) as count\n        FROM feedback f\n        WHERE (p_session_id IS NULL OR f.session_id = p_session_id)\n        AND rating IS NOT NULL\n        GROUP BY rating\n        ORDER BY rating\n    ) rating_counts;\n    \n    RETURN QUERY\n    SELECT v_total, v_avg, COALESCE(v_distribution, '{}'::jsonb);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_by_id",
    "arguments": "p_group_id integer",
    "return_type": "TABLE(id integer, name text, description text, member_count bigint, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_by_id(p_group_id integer)\n RETURNS TABLE(id integer, name text, description text, member_count bigint, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        g.group_id::INTEGER as id,\n        g.name,\n        COALESCE(g.description, '') as description,\n        COUNT(gp.user_id) as member_count,\n        g.created_at\n    FROM groups g\n    LEFT JOIN group_participants gp ON g.group_id = gp.group_id\n    WHERE g.group_id = p_group_id\n    GROUP BY g.group_id, g.name, g.description, g.created_at;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_by_name",
    "arguments": "p_name text",
    "return_type": "TABLE(id integer, name text)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_by_name(p_name text)\n RETURNS TABLE(id integer, name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        g.group_id::INTEGER as id,\n        g.name\n    FROM groups g\n    WHERE LOWER(g.name) = LOWER(p_name)\n    LIMIT 1;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Group with name ''%'' not found', p_name USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_chat_messages",
    "arguments": "p_session_id integer, p_limit integer, p_offset integer",
    "return_type": "TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, sender_user_id integer, content text, message_type character varying, metadata jsonb, sent_at timestamp without time zone, edited_at timestamp without time zone, reply_to integer)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_chat_messages(p_session_id integer, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, sender_user_id integer, content text, message_type character varying, metadata jsonb, sent_at timestamp without time zone, edited_at timestamp without time zone, reply_to integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Validate input\n    IF p_session_id IS NULL THEN\n        RAISE EXCEPTION 'Session ID is required' USING ERRCODE = '23514';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        m.message_id,\n        m.session_id,\n        m.sender_id,\n        COALESCE(u.first_name || ' ' || u.last_name, u.email) as sender_name,\n        gp.user_id as sender_user_id,\n        m.content,\n        m.message_type,\n        m.metadata,\n        m.sent_at,\n        m.edited_at,\n        m.reply_to\n    FROM messages m\n    JOIN group_participants gp ON m.sender_id = gp.group_participant_id\n    JOIN users u ON gp.user_id = u.user_id\n    WHERE m.session_id = p_session_id\n    ORDER BY m.sent_at DESC\n    LIMIT p_limit OFFSET p_offset;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_chat_sessions",
    "arguments": "p_group_id integer",
    "return_type": "TABLE(session_id integer, title text, description text, status character varying, created_by integer, creator_name text, participant_count bigint, last_message_at timestamp without time zone, last_message_content text, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_chat_sessions(p_group_id integer)\n RETURNS TABLE(session_id integer, title text, description text, status character varying, created_by integer, creator_name text, participant_count bigint, last_message_at timestamp without time zone, last_message_content text, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Validate input\n    IF p_group_id IS NULL THEN\n        RAISE EXCEPTION 'Group ID is required' USING ERRCODE = '23514';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        s.session_id,\n        COALESCE(s.topic, 'Group Chat Session') as title,\n        ''::TEXT as description,\n        s.status::VARCHAR(20),\n        s.created_by,\n        COALESCE(u.first_name || ' ' || u.last_name, u.email) as creator_name,\n        COUNT(DISTINCT sp.user_id) as participant_count,\n        MAX(m.sent_at)::TIMESTAMP as last_message_at,  -- Simple cast to remove timezone\n        (\n            SELECT content FROM messages \n            WHERE messages.session_id = s.session_id\n            ORDER BY sent_at DESC \n            LIMIT 1\n        ) as last_message_content,\n        s.started_at::TIMESTAMP as created_at  -- Simple cast to remove timezone\n    FROM sessions s\n    JOIN users u ON s.created_by = u.user_id\n    LEFT JOIN session_participants sp ON s.session_id = sp.session_id\n    LEFT JOIN messages m ON s.session_id = m.session_id\n    WHERE s.group_id = p_group_id\n    AND s.status = 'active'\n    GROUP BY s.session_id, s.topic, s.status, s.created_by, u.first_name, u.last_name, u.email, s.started_at\n    ORDER BY COALESCE(MAX(m.sent_at)::TIMESTAMP, s.started_at::TIMESTAMP) DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_members",
    "arguments": "p_group_id integer",
    "return_type": "TABLE(group_id integer, member_ids integer[], member_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_members(p_group_id integer)\n RETURNS TABLE(group_id integer, member_ids integer[], member_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_member_ids INTEGER[];\n    v_count BIGINT;\nBEGIN\n    -- Check if group exists\n    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get member IDs\n    SELECT ARRAY_AGG(gp.user_id), COUNT(gp.user_id)\n    INTO v_member_ids, v_count\n    FROM group_participants gp\n    WHERE gp.group_id = p_group_id;\n    \n    RETURN QUERY\n    SELECT \n        p_group_id as group_id,\n        COALESCE(v_member_ids, ARRAY[]::INTEGER[]) as member_ids,\n        COALESCE(v_count, 0) as member_count;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_group_members_detailed",
    "arguments": "p_group_id integer",
    "return_type": "TABLE(user_id integer, name text, email text, role character varying, joined_at timestamp without time zone, is_active boolean, first_name text, last_name text)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_group_members_detailed(p_group_id integer)\n RETURNS TABLE(user_id integer, name text, email text, role character varying, joined_at timestamp without time zone, is_active boolean, first_name text, last_name text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if group exists\n    IF NOT EXISTS (SELECT 1 FROM groups WHERE group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n\n    RETURN QUERY\n    SELECT \n        u.user_id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as name,\n        u.email,\n        gp.role,\n        gp.joined_at,\n        CASE WHEN u.availability = 'available' THEN true ELSE false END as is_active,\n        u.first_name,\n        u.last_name\n    FROM group_participants gp\n    INNER JOIN users u ON gp.user_id = u.user_id\n    WHERE gp.group_id = p_group_id\n    ORDER BY gp.joined_at ASC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_message_ai_metadata",
    "arguments": "p_message_id integer",
    "return_type": "TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_message_ai_metadata(p_message_id integer)\n RETURNS TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        am.ai_metadata_id::INTEGER as id,\n        am.message_id::INTEGER as message_id,\n        am.model_name,\n        am.input_tokens::INTEGER as input_tokens,\n        am.output_tokens::INTEGER as output_tokens,\n        am.cost,\n        am.processing_time,\n        am.created_at\n    FROM ai_metadata am\n    WHERE am.message_id = p_message_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_message_by_id",
    "arguments": "p_message_id integer",
    "return_type": "TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_message_by_id(p_message_id integer)\n RETURNS TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        m.message_id::INTEGER,\n        m.session_id::INTEGER,\n        gp.user_id::INTEGER as sender_id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as sender_name,\n        m.content,\n        m.sent_at\n    FROM messages m\n    JOIN group_participants gp ON m.sender_id = gp.group_participant_id\n    JOIN users u ON gp.user_id = u.user_id\n    WHERE m.message_id = p_message_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Message with ID % not found', p_message_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_message_feedback",
    "arguments": "p_message_id integer",
    "return_type": "TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_message_feedback(p_message_id integer)\n RETURNS TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Note: This requires a relationship between feedback and messages\n    -- For now, return empty result set as the schema doesn't have this relationship\n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER as id,\n        f.session_id::INTEGER as session_id,\n        f.given_by::INTEGER as given_by,\n        f.content,\n        f.rating::INTEGER as rating,\n        f.created_at\n    FROM feedback f\n    WHERE 1=0; -- Always return empty for now\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_paper_by_id",
    "arguments": "p_paper_id integer",
    "return_type": "TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone, tags text[])",
    "definition": "CREATE OR REPLACE FUNCTION public.get_paper_by_id(p_paper_id integer)\n RETURNS TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone, tags text[])\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_tags TEXT[];\nBEGIN\n    -- Check if paper exists\n    IF NOT EXISTS (SELECT 1 FROM papers WHERE paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper with ID % not found', p_paper_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get paper tags\n    SELECT ARRAY_AGG(pt.tag) INTO v_tags\n    FROM paper_tags pt\n    WHERE pt.paper_id = p_paper_id;\n    \n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        p.published_at,\n        p.source_url,\n        p.created_at,\n        COALESCE(v_tags, ARRAY[]::TEXT[]) as tags\n    FROM papers p\n    WHERE p.paper_id = p_paper_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_related_papers",
    "arguments": "p_paper_id integer, p_limit integer",
    "return_type": "TABLE(id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, relevance_score numeric)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_related_papers(p_paper_id integer, p_limit integer DEFAULT 5)\n RETURNS TABLE(id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, relevance_score numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Simple implementation based on shared words in title/abstract\n    -- This could be enhanced with more sophisticated matching\n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER as id,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        p.published_at,\n        p.source_url,\n        0.5::NUMERIC as relevance_score -- Placeholder relevance score\n    FROM papers p\n    WHERE p.paper_id != p_paper_id\n    ORDER BY p.published_at DESC\n    LIMIT p_limit;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_by_id",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_by_id(p_session_id integer)\n RETURNS TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status character varying, participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        s.session_id::INTEGER as id,\n        COALESCE(s.topic, 'Untitled Session') as title,\n        ''::TEXT as description,\n        s.created_by::INTEGER as created_by,\n        s.group_id::INTEGER as group_id,\n        s.started_at as created_at,\n        s.started_at as started_at,\n        s.ended_at as ended_at,\n        s.status as status,  -- Removed unnecessary cast\n        COUNT(DISTINCT sp.user_id) as participant_count\n    FROM sessions s\n    LEFT JOIN session_participants sp ON s.session_id = sp.session_id\n    WHERE s.session_id = p_session_id\n    GROUP BY s.session_id, s.topic, s.created_by, s.group_id, s.started_at, s.ended_at, s.status;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_by_title",
    "arguments": "p_title text",
    "return_type": "TABLE(id integer, title text)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_by_title(p_title text)\n RETURNS TABLE(id integer, title text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        s.session_id::INTEGER as id,\n        s.topic as title\n    FROM sessions s\n    WHERE LOWER(s.topic) = LOWER(p_title)\n    LIMIT 1;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Session with title ''%'' not found', p_title USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_feedback",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(feedback_id integer, session_id integer, given_by integer, given_by_name text, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_feedback(p_session_id integer)\n RETURNS TABLE(feedback_id integer, session_id integer, given_by integer, given_by_name text, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER,\n        f.session_id::INTEGER,\n        gp.user_id::INTEGER as given_by,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as given_by_name,\n        f.content,\n        f.rating,\n        f.created_at\n    FROM feedback f\n    JOIN group_participants gp ON f.given_by = gp.group_participant_id\n    JOIN users u ON gp.user_id = u.user_id\n    WHERE f.session_id = p_session_id\n    ORDER BY f.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_messages",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_messages(p_session_id integer)\n RETURNS TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        m.message_id::INTEGER,\n        m.session_id::INTEGER,\n        gp.user_id::INTEGER as sender_id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as sender_name,\n        m.content,\n        m.sent_at\n    FROM messages m\n    JOIN group_participants gp ON m.sender_id = gp.group_participant_id\n    JOIN users u ON gp.user_id = u.user_id\n    WHERE m.session_id = p_session_id\n    ORDER BY m.sent_at ASC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_online_users",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(user_id integer, username text, status character varying, last_seen timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_online_users(p_session_id integer)\n RETURNS TABLE(user_id integer, username text, status character varying, last_seen timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        up.user_id,\n        COALESCE(u.first_name || ' ' || u.last_name, u.email) as username,\n        up.status,\n        up.last_seen\n    FROM user_presence up\n    JOIN users u ON up.user_id = u.user_id\n    WHERE up.session_id = p_session_id\n    AND up.status IN ('online', 'away')\n    ORDER BY up.last_seen DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_papers",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(paper_id integer, title text, abstract text, authors text, doi text, added_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_papers(p_session_id integer)\n RETURNS TABLE(paper_id integer, title text, abstract text, authors text, doi text, added_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        sp.added_at\n    FROM session_papers sp\n    JOIN papers p ON sp.paper_id = p.paper_id\n    WHERE sp.session_id = p_session_id\n    ORDER BY sp.added_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_participants",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(session_id integer, participant_ids integer[], participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_participants(p_session_id integer)\n RETURNS TABLE(session_id integer, participant_ids integer[], participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_participant_ids INTEGER[];\n    v_count BIGINT;\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get participant IDs\n    SELECT ARRAY_AGG(sp.user_id), COUNT(sp.user_id)\n    INTO v_participant_ids, v_count\n    FROM session_participants sp\n    WHERE sp.session_id = p_session_id;\n    \n    RETURN QUERY\n    SELECT \n        p_session_id as session_id,\n        COALESCE(v_participant_ids, ARRAY[]::INTEGER[]) as participant_ids,\n        COALESCE(v_count, 0) as participant_count;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_session_summary",
    "arguments": "p_session_id integer",
    "return_type": "TABLE(session_id integer, title text, message_count bigint, duration text, is_active boolean)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_session_summary(p_session_id integer)\n RETURNS TABLE(session_id integer, title text, message_count bigint, duration text, is_active boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_session_info RECORD;\n    v_message_count BIGINT;\n    v_duration TEXT;\nBEGIN\n    -- Get session info\n    SELECT s.session_id, s.topic, s.status, s.started_at, s.ended_at\n    INTO v_session_info\n    FROM sessions s\n    WHERE s.session_id = p_session_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Get message count\n    SELECT COUNT(*) INTO v_message_count\n    FROM messages m\n    WHERE m.session_id = p_session_id;\n    \n    -- Calculate duration\n    IF v_session_info.ended_at IS NOT NULL THEN\n        v_duration := EXTRACT(EPOCH FROM (v_session_info.ended_at - v_session_info.started_at))::TEXT || ' seconds';\n    ELSE\n        v_duration := 'Session in progress';\n    END IF;\n    \n    RETURN QUERY\n    SELECT \n        p_session_id as session_id,\n        COALESCE(v_session_info.topic, 'Untitled Session') as title,\n        v_message_count as message_count,\n        v_duration as duration,\n        CASE WHEN v_session_info.status = 'active' THEN true ELSE false END as is_active;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_by_auth_id",
    "arguments": "auth_id uuid",
    "return_type": "SETOF users",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_by_auth_id(auth_id uuid)\n RETURNS SETOF users\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT * FROM public.users\n  WHERE auth_user_id = auth_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_by_id",
    "arguments": "p_user_id integer",
    "return_type": "TABLE(id integer, name text, email text, is_active boolean, first_name text, last_name text, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_by_id(p_user_id integer)\n RETURNS TABLE(id integer, name text, email text, is_active boolean, first_name text, last_name text, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        u.user_id::INTEGER as id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as name,\n        u.email,\n        CASE WHEN u.availability = 'available' THEN true ELSE false END as is_active,\n        u.first_name,\n        u.last_name,\n        u.created_at\n    FROM users u\n    WHERE u.user_id = p_user_id;\n    \n    -- If no user found, raise exception\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_feedback",
    "arguments": "p_user_id integer",
    "return_type": "TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_feedback(p_user_id integer)\n RETURNS TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER as id,\n        f.session_id::INTEGER as session_id,\n        f.given_by::INTEGER as given_by,\n        f.content,\n        f.rating::INTEGER as rating,\n        f.created_at\n    FROM feedback f\n    WHERE f.given_by = p_user_id\n    ORDER BY f.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "get_user_groups",
    "arguments": "p_user_id integer",
    "return_type": "TABLE(id integer, group_id integer, name text, description text, is_public boolean, invite_code character varying, member_count bigint, user_role character varying, created_at timestamp without time zone, created_by integer)",
    "definition": "CREATE OR REPLACE FUNCTION public.get_user_groups(p_user_id integer)\n RETURNS TABLE(id integer, group_id integer, name text, description text, is_public boolean, invite_code character varying, member_count bigint, user_role character varying, created_at timestamp without time zone, created_by integer)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n\n    RETURN QUERY\n    SELECT \n        g.group_id as id,\n        g.group_id,\n        g.name,\n        COALESCE(g.description, '') as description,\n        COALESCE(g.is_public, false) as is_public,\n        g.invite_code,\n        (\n            SELECT COUNT(*)::BIGINT \n            FROM group_participants gp2 \n            WHERE gp2.group_id = g.group_id\n        ) as member_count,\n        gp.role as user_role,\n        g.created_at,\n        g.created_by\n    FROM groups g\n    INNER JOIN group_participants gp ON g.group_id = gp.group_id\n    WHERE gp.user_id = p_user_id\n    ORDER BY g.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_new_user",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_name TEXT;\n    name_parts TEXT[];\n    first_name_val TEXT;\n    last_name_val TEXT;\nBEGIN\n    -- Extract name information from user metadata\n    user_name := COALESCE(\n        NEW.raw_user_meta_data->>'full_name',\n        NEW.raw_user_meta_data->>'name',\n        split_part(NEW.email, '@', 1)\n    );\n    \n    -- Parse name into first and last name\n    IF user_name IS NOT NULL AND user_name != '' THEN\n        name_parts := string_to_array(trim(user_name), ' ');\n        first_name_val := name_parts[1];\n        \n        -- Combine remaining parts for last name\n        IF array_length(name_parts, 1) > 1 THEN\n            last_name_val := array_to_string(name_parts[2:], ' ');\n        END IF;\n    ELSE\n        first_name_val := split_part(NEW.email, '@', 1);\n        last_name_val := NULL;\n    END IF;\n\n    -- Insert new user with better error handling\n    BEGIN\n        INSERT INTO public.users (\n            auth_user_id,\n            email,\n            first_name,\n            last_name,\n            profile_picture_url,\n            provider,\n            provider_id,\n            last_sign_in_at,\n            raw_app_meta_data,\n            raw_user_meta_data,\n            availability,\n            created_at,\n            updated_at\n        )\n        VALUES (\n            NEW.id,\n            NEW.email,\n            first_name_val,\n            last_name_val,\n            NEW.raw_user_meta_data->>'avatar_url',\n            COALESCE(NEW.raw_app_meta_data->>'provider', 'google'),\n            NEW.raw_app_meta_data->>'provider_id',\n            NEW.last_sign_in_at,\n            NEW.raw_app_meta_data,\n            NEW.raw_user_meta_data,\n            'available',\n            NEW.created_at,\n            CURRENT_TIMESTAMP\n        )\n        ON CONFLICT (auth_user_id) DO UPDATE SET\n            email = EXCLUDED.email,\n            first_name = COALESCE(EXCLUDED.first_name, users.first_name),\n            last_name = COALESCE(EXCLUDED.last_name, users.last_name),\n            profile_picture_url = COALESCE(EXCLUDED.profile_picture_url, users.profile_picture_url),\n            last_sign_in_at = EXCLUDED.last_sign_in_at,\n            raw_app_meta_data = EXCLUDED.raw_app_meta_data,\n            raw_user_meta_data = EXCLUDED.raw_user_meta_data,\n            updated_at = CURRENT_TIMESTAMP;\n\n        RAISE LOG 'Successfully created/updated user for auth_user_id: %, email: %', NEW.id, NEW.email;\n        \n    EXCEPTION WHEN OTHERS THEN\n        RAISE LOG 'Error creating user for auth_user_id %, email %: %', NEW.id, NEW.email, SQLERRM;\n        -- Don't prevent the auth user creation if this fails\n    END;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_new_user_from_update",
    "arguments": "user_record auth.users",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_new_user_from_update(user_record auth.users)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_name TEXT;\n    name_parts TEXT[];\n    first_name_val TEXT;\n    last_name_val TEXT;\nBEGIN\n    user_name := COALESCE(\n        user_record.raw_user_meta_data->>'full_name',\n        user_record.raw_user_meta_data->>'name',\n        split_part(user_record.email, '@', 1)\n    );\n    \n    IF user_name IS NOT NULL AND user_name != '' THEN\n        name_parts := string_to_array(trim(user_name), ' ');\n        first_name_val := name_parts[1];\n        \n        IF array_length(name_parts, 1) > 1 THEN\n            last_name_val := array_to_string(name_parts[2:], ' ');\n        END IF;\n    ELSE\n        first_name_val := split_part(user_record.email, '@', 1);\n        last_name_val := NULL;\n    END IF;\n\n    INSERT INTO public.users (\n        auth_user_id,\n        email,\n        first_name,\n        last_name,\n        profile_picture_url,\n        provider,\n        provider_id,\n        last_sign_in_at,\n        raw_app_meta_data,\n        raw_user_meta_data,\n        availability,\n        created_at,\n        updated_at\n    )\n    VALUES (\n        user_record.id,\n        user_record.email,\n        first_name_val,\n        last_name_val,\n        user_record.raw_user_meta_data->>'avatar_url',\n        COALESCE(user_record.raw_app_meta_data->>'provider', 'google'),\n        user_record.raw_app_meta_data->>'provider_id',\n        user_record.last_sign_in_at,\n        user_record.raw_app_meta_data,\n        user_record.raw_user_meta_data,\n        'available',\n        user_record.created_at,\n        CURRENT_TIMESTAMP\n    )\n    ON CONFLICT (auth_user_id) DO NOTHING;\n    \n    RAISE LOG 'Created missing user record for auth_user_id: %', user_record.id;\n    \nEXCEPTION WHEN OTHERS THEN\n    RAISE LOG 'Error creating missing user record for auth_user_id %: %', user_record.id, SQLERRM;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "handle_user_update",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.handle_user_update()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    user_name TEXT;\n    name_parts TEXT[];\n    first_name_val TEXT;\n    last_name_val TEXT;\n    rows_affected INTEGER;\nBEGIN\n    -- Only process if relevant fields changed\n    IF NEW.email = OLD.email \n       AND NEW.last_sign_in_at = OLD.last_sign_in_at \n       AND NEW.raw_user_meta_data = OLD.raw_user_meta_data \n       AND NEW.raw_app_meta_data = OLD.raw_app_meta_data THEN\n        RETURN NEW;\n    END IF;\n\n    -- Extract updated name information\n    user_name := COALESCE(\n        NEW.raw_user_meta_data->>'full_name',\n        NEW.raw_user_meta_data->>'name'\n    );\n    \n    IF user_name IS NOT NULL AND user_name != '' THEN\n        name_parts := string_to_array(trim(user_name), ' ');\n        first_name_val := name_parts[1];\n        \n        IF array_length(name_parts, 1) > 1 THEN\n            last_name_val := array_to_string(name_parts[2:], ' ');\n        END IF;\n    END IF;\n\n    BEGIN\n        UPDATE public.users\n        SET\n            email = NEW.email,\n            first_name = COALESCE(first_name_val, first_name),\n            last_name = COALESCE(last_name_val, last_name),\n            profile_picture_url = COALESCE(NEW.raw_user_meta_data->>'avatar_url', profile_picture_url),\n            last_sign_in_at = NEW.last_sign_in_at,\n            raw_app_meta_data = NEW.raw_app_meta_data,\n            raw_user_meta_data = NEW.raw_user_meta_data,\n            updated_at = CURRENT_TIMESTAMP\n        WHERE auth_user_id = NEW.id;\n        \n        GET DIAGNOSTICS rows_affected = ROW_COUNT;\n        \n        IF rows_affected = 0 THEN\n            RAISE LOG 'No user found to update for auth_user_id: %', NEW.id;\n            -- Try to create the user if update failed\n            PERFORM public.handle_new_user_from_update(NEW);\n        ELSE\n            RAISE LOG 'Successfully updated user for auth_user_id: %, rows affected: %', NEW.id, rows_affected;\n        END IF;\n        \n    EXCEPTION WHEN OTHERS THEN\n        RAISE LOG 'Error updating user for auth_user_id %: %', NEW.id, SQLERRM;\n    END;\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "join_group_by_invite_code",
    "arguments": "p_invite_code text, p_user_id integer",
    "return_type": "json",
    "definition": "CREATE OR REPLACE FUNCTION public.join_group_by_invite_code(p_invite_code text, p_user_id integer)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_group_id INTEGER;\nBEGIN\n    -- Find group by invite code\n    SELECT g.group_id INTO v_group_id\n    FROM groups g\n    WHERE g.invite_code = p_invite_code;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Invalid invite code' USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Check if user is already a member\n    IF EXISTS (SELECT 1 FROM group_participants WHERE group_id = v_group_id AND user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User is already a member of this group' USING ERRCODE = '23505';\n    END IF;\n    \n    -- Add user to group\n    INSERT INTO group_participants (group_id, user_id, role)\n    VALUES (v_group_id, p_user_id, 'member');\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Successfully joined group',\n        'group_id', v_group_id\n    );\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "join_group_chat_session",
    "arguments": "p_session_id integer, p_user_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.join_group_chat_session(p_session_id integer, p_user_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Validate inputs\n    IF p_session_id IS NULL OR p_user_id IS NULL THEN\n        RAISE EXCEPTION 'Session ID and User ID are required' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Check if user is member of the group that owns this session\n    IF NOT EXISTS (\n        SELECT 1 FROM sessions s\n        JOIN group_participants gp ON s.group_id = gp.group_id\n        WHERE s.session_id = p_session_id\n        AND gp.user_id = p_user_id\n    ) THEN\n        RAISE EXCEPTION 'User is not a member of the group' USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Add user to session participants (ignore if already exists)\n    INSERT INTO session_participants (session_id, user_id)\n    VALUES (p_session_id, p_user_id)\n    ON CONFLICT (session_id, user_id) DO NOTHING;\n    \n    -- Set user as online in this session\n    INSERT INTO user_presence (user_id, session_id, status)\n    VALUES (p_user_id, p_session_id, 'online')\n    ON CONFLICT (user_id, session_id) \n    DO UPDATE SET status = 'online', last_seen = CURRENT_TIMESTAMP;\n    \n    RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "log_ai_invocation",
    "arguments": "p_user_id integer, p_session_id integer, p_trigger_message_id integer, p_ai_message_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.log_ai_invocation(p_user_id integer, p_session_id integer, p_trigger_message_id integer, p_ai_message_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- This function can be used to log AI usage for analytics\n    -- For now, we'll just return true, but could expand to include logging table\n    RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "remove_group_member",
    "arguments": "p_group_id integer, p_user_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.remove_group_member(p_group_id integer, p_user_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_deleted_count INTEGER;\nBEGIN\n    -- Check if group exists\n    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN\n        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Remove user from group\n    DELETE FROM group_participants \n    WHERE group_id = p_group_id AND user_id = p_user_id;\n    \n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    \n    IF v_deleted_count = 0 THEN\n        RAISE EXCEPTION 'User % is not a member of group %', p_user_id, p_group_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "remove_paper_from_session",
    "arguments": "p_session_id integer, p_paper_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.remove_paper_from_session(p_session_id integer, p_paper_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if association exists\n    IF NOT EXISTS (\n        SELECT 1 FROM session_papers \n        WHERE session_id = p_session_id AND paper_id = p_paper_id\n    ) THEN\n        RAISE EXCEPTION 'Paper % is not associated with session %', p_paper_id, p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Remove association\n    DELETE FROM session_papers \n    WHERE session_id = p_session_id AND paper_id = p_paper_id;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "remove_session_participant",
    "arguments": "p_session_id integer, p_user_id integer",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.remove_session_participant(p_session_id integer, p_user_id integer)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_deleted_count INTEGER;\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Remove user from session\n    DELETE FROM session_participants \n    WHERE session_id = p_session_id AND user_id = p_user_id;\n    \n    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;\n    \n    IF v_deleted_count = 0 THEN\n        RAISE EXCEPTION 'User % is not a participant in session %', p_user_id, p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    RETURN true;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "search_messages",
    "arguments": "p_query_text text, p_session_id integer, p_limit integer",
    "return_type": "TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.search_messages(p_query_text text, p_session_id integer DEFAULT NULL::integer, p_limit integer DEFAULT 50)\n RETURNS TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        m.message_id::INTEGER as id,\n        m.session_id::INTEGER as session_id,\n        m.sender_id::INTEGER as sender_id,\n        m.content,\n        COALESCE(m.message_type, 'user') as message_type,\n        m.sent_at\n    FROM messages m\n    WHERE (p_session_id IS NULL OR m.session_id = p_session_id)\n      AND m.content ILIKE '%' || p_query_text || '%'\n    ORDER BY m.sent_at DESC\n    LIMIT p_limit;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "search_papers",
    "arguments": "p_query text",
    "return_type": "TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone, relevance_score real)",
    "definition": "CREATE OR REPLACE FUNCTION public.search_papers(p_query text)\n RETURNS TABLE(paper_id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text, created_at timestamp without time zone, relevance_score real)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        p.published_at,\n        p.source_url,\n        p.created_at,\n        CASE \n            WHEN LOWER(p.title) LIKE LOWER('%' || p_query || '%') THEN 1.0\n            WHEN LOWER(p.abstract) LIKE LOWER('%' || p_query || '%') THEN 0.8\n            WHEN LOWER(p.authors) LIKE LOWER('%' || p_query || '%') THEN 0.6\n            ELSE 0.4\n        END as relevance_score\n    FROM papers p\n    WHERE \n        LOWER(p.title) LIKE LOWER('%' || p_query || '%') OR\n        LOWER(p.abstract) LIKE LOWER('%' || p_query || '%') OR\n        LOWER(p.authors) LIKE LOWER('%' || p_query || '%') OR\n        EXISTS (\n            SELECT 1 FROM paper_tags pt \n            WHERE pt.paper_id = p.paper_id \n            AND LOWER(pt.tag) LIKE LOWER('%' || p_query || '%')\n        )\n    ORDER BY relevance_score DESC, p.created_at DESC;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "send_group_chat_message",
    "arguments": "p_session_id integer, p_user_id integer, p_content text, p_message_type character varying, p_metadata jsonb",
    "return_type": "TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, message_type character varying, metadata jsonb, sent_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.send_group_chat_message(p_session_id integer, p_user_id integer, p_content text, p_message_type character varying DEFAULT 'user'::character varying, p_metadata jsonb DEFAULT '{}'::jsonb)\n RETURNS TABLE(message_id integer, session_id integer, sender_id integer, sender_name text, content text, message_type character varying, metadata jsonb, sent_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_message_id INTEGER;\n    v_sender_id INTEGER;\n    v_sender_name TEXT;\n    v_timestamp TIMESTAMP := CURRENT_TIMESTAMP;\nBEGIN\n    -- Obama's validation\n    IF p_session_id IS NULL OR p_user_id IS NULL OR p_content IS NULL OR TRIM(p_content) = '' THEN\n        RAISE EXCEPTION 'Obama says: Session ID, User ID, and Content are required!' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Find sender with Obama's blessing (completely separate query)\n    WITH sender_lookup AS (\n        SELECT \n            gp.group_participant_id as participant_id,\n            COALESCE(u.first_name || ' ' || u.last_name, u.email) as full_name\n        FROM sessions s\n        JOIN group_participants gp ON s.group_id = gp.group_id\n        JOIN users u ON gp.user_id = u.user_id\n        WHERE s.session_id = p_session_id AND gp.user_id = p_user_id\n    )\n    SELECT participant_id, full_name INTO v_sender_id, v_sender_name FROM sender_lookup;\n    \n    IF v_sender_id IS NULL THEN\n        RAISE EXCEPTION 'Obama says: User % is not in session %!', p_user_id, p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Insert message (Obama style - clean and simple)\n    WITH message_insert AS (\n        INSERT INTO messages (session_id, sender_id, content, message_type, metadata, sent_at)\n        VALUES (p_session_id, v_sender_id, p_content, p_message_type, p_metadata, v_timestamp)\n        RETURNING message_id\n    )\n    SELECT message_id INTO v_message_id FROM message_insert;\n    \n    -- Obama's presence update (simple upsert)\n    WITH presence_upsert AS (\n        INSERT INTO user_presence (user_id, session_id, status, last_seen)\n        VALUES (p_user_id, p_session_id, 'online', v_timestamp)\n        ON CONFLICT (user_id, session_id) \n        DO UPDATE SET status = 'online', last_seen = v_timestamp\n        RETURNING 1 as updated\n    )\n    SELECT 1 FROM presence_upsert;\n    \n    -- Obama's return (pure variables, no table conflicts possible)\n    message_id := v_message_id;\n    session_id := p_session_id;\n    sender_id := v_sender_id;\n    sender_name := v_sender_name;\n    content := p_content;\n    message_type := p_message_type;\n    metadata := p_metadata;\n    sent_at := v_timestamp;\n    \n    RETURN NEXT;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "set_group_invite_code",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.set_group_invite_code()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Generate unique invite code if not provided\n    IF NEW.invite_code IS NULL THEN\n        LOOP\n            NEW.invite_code := generate_invite_code();\n            -- Check if code is unique\n            IF NOT EXISTS (SELECT 1 FROM groups WHERE invite_code = NEW.invite_code) THEN\n                EXIT;\n            END IF;\n        END LOOP;\n    END IF;\n    \n    -- Set updated_at timestamp\n    NEW.updated_at := CURRENT_TIMESTAMP;\n    \n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "sync_existing_auth_users",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION public.sync_existing_auth_users()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    auth_user RECORD;\n    synced_count INTEGER := 0;\n    error_count INTEGER := 0;\nBEGIN\n    FOR auth_user IN \n        SELECT * FROM auth.users \n        WHERE id NOT IN (SELECT auth_user_id FROM public.users WHERE auth_user_id IS NOT NULL)\n    LOOP\n        BEGIN\n            PERFORM public.handle_new_user_from_update(auth_user);\n            synced_count := synced_count + 1;\n        EXCEPTION WHEN OTHERS THEN\n            error_count := error_count + 1;\n            RAISE LOG 'Failed to sync auth user %: %', auth_user.id, SQLERRM;\n        END;\n    END LOOP;\n    \n    RETURN format('Synced %s users, %s errors', synced_count, error_count);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_ai_metadata",
    "arguments": "p_ai_metadata_id integer, p_model_name text, p_input_tokens integer, p_output_tokens integer, p_cost numeric, p_processing_time numeric",
    "return_type": "TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_ai_metadata(p_ai_metadata_id integer, p_model_name text DEFAULT NULL::text, p_input_tokens integer DEFAULT NULL::integer, p_output_tokens integer DEFAULT NULL::integer, p_cost numeric DEFAULT NULL::numeric, p_processing_time numeric DEFAULT NULL::numeric)\n RETURNS TABLE(id integer, message_id integer, model_name text, input_tokens integer, output_tokens integer, cost numeric, processing_time numeric, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if AI metadata exists\n    IF NOT EXISTS (SELECT 1 FROM ai_metadata WHERE ai_metadata_id = p_ai_metadata_id) THEN\n        RAISE EXCEPTION 'AI metadata with ID % not found', p_ai_metadata_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update AI metadata\n    UPDATE ai_metadata \n    SET \n        model_name = COALESCE(p_model_name, model_name),\n        input_tokens = COALESCE(p_input_tokens, input_tokens),\n        output_tokens = COALESCE(p_output_tokens, output_tokens),\n        cost = COALESCE(p_cost, cost),\n        processing_time = COALESCE(p_processing_time, processing_time)\n    WHERE ai_metadata_id = p_ai_metadata_id;\n    \n    -- Return updated AI metadata\n    RETURN QUERY\n    SELECT \n        am.ai_metadata_id::INTEGER as id,\n        am.message_id::INTEGER as message_id,\n        am.model_name,\n        am.input_tokens::INTEGER as input_tokens,\n        am.output_tokens::INTEGER as output_tokens,\n        am.cost,\n        am.processing_time,\n        am.created_at\n    FROM ai_metadata am\n    WHERE am.ai_metadata_id = p_ai_metadata_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_feedback",
    "arguments": "p_feedback_id integer, p_content text, p_rating integer",
    "return_type": "TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_feedback(p_feedback_id integer, p_content text DEFAULT NULL::text, p_rating integer DEFAULT NULL::integer)\n RETURNS TABLE(id integer, session_id integer, given_by integer, content text, rating integer, created_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if feedback exists\n    IF NOT EXISTS (SELECT 1 FROM feedback WHERE feedback_id = p_feedback_id) THEN\n        RAISE EXCEPTION 'Feedback with ID % not found', p_feedback_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update feedback\n    UPDATE feedback \n    SET \n        content = COALESCE(p_content, content),\n        rating = COALESCE(p_rating, rating)\n    WHERE feedback_id = p_feedback_id;\n    \n    -- Return updated feedback\n    RETURN QUERY\n    SELECT \n        f.feedback_id::INTEGER as id,\n        f.session_id::INTEGER as session_id,\n        f.given_by::INTEGER as given_by,\n        f.content,\n        f.rating::INTEGER as rating,\n        f.created_at\n    FROM feedback f\n    WHERE f.feedback_id = p_feedback_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_message",
    "arguments": "p_message_id integer, p_content text",
    "return_type": "TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone, edited_at timestamp without time zone)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_message(p_message_id integer, p_content text)\n RETURNS TABLE(id integer, session_id integer, sender_id integer, content text, message_type character varying, sent_at timestamp without time zone, edited_at timestamp without time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if message exists\n    IF NOT EXISTS (SELECT 1 FROM messages WHERE message_id = p_message_id) THEN\n        RAISE EXCEPTION 'Message with ID % not found', p_message_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update message\n    UPDATE messages \n    SET content = p_content, edited_at = CURRENT_TIMESTAMP\n    WHERE message_id = p_message_id;\n    \n    -- Return updated message\n    RETURN QUERY\n    SELECT \n        m.message_id::INTEGER as id,\n        m.session_id::INTEGER as session_id,\n        m.sender_id::INTEGER as sender_id,\n        m.content,\n        COALESCE(m.message_type, 'user') as message_type,\n        m.sent_at,\n        m.edited_at\n    FROM messages m\n    WHERE m.message_id = p_message_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_paper",
    "arguments": "p_paper_id integer, p_title text, p_abstract text, p_authors text, p_doi text, p_source_url text",
    "return_type": "TABLE(id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_paper(p_paper_id integer, p_title text DEFAULT NULL::text, p_abstract text DEFAULT NULL::text, p_authors text DEFAULT NULL::text, p_doi text DEFAULT NULL::text, p_source_url text DEFAULT NULL::text)\n RETURNS TABLE(id integer, title text, abstract text, authors text, doi text, published_at timestamp without time zone, source_url text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if paper exists\n    IF NOT EXISTS (SELECT 1 FROM papers WHERE paper_id = p_paper_id) THEN\n        RAISE EXCEPTION 'Paper with ID % not found', p_paper_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Update paper\n    UPDATE papers \n    SET \n        title = COALESCE(p_title, title),\n        abstract = COALESCE(p_abstract, abstract),\n        authors = COALESCE(p_authors, authors),\n        doi = COALESCE(p_doi, doi),\n        source_url = COALESCE(p_source_url, source_url)\n    WHERE paper_id = p_paper_id;\n    \n    -- Return updated paper\n    RETURN QUERY\n    SELECT \n        p.paper_id::INTEGER as id,\n        p.title,\n        p.abstract,\n        p.authors,\n        p.doi,\n        p.published_at,\n        p.source_url\n    FROM papers p\n    WHERE p.paper_id = p_paper_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_session",
    "arguments": "p_session_id integer, p_title text, p_status text",
    "return_type": "TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status text, participant_count bigint)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_session(p_session_id integer, p_title text DEFAULT NULL::text, p_status text DEFAULT NULL::text)\n RETURNS TABLE(id integer, title text, description text, created_by integer, group_id integer, created_at timestamp without time zone, started_at timestamp without time zone, ended_at timestamp without time zone, status text, participant_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_ended_at TIMESTAMP := NULL;\nBEGIN\n    -- Check if session exists\n    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN\n        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Validate status if provided\n    IF p_status IS NOT NULL AND p_status NOT IN ('offline', 'active', 'completed') THEN\n        RAISE EXCEPTION 'Invalid status. Must be offline, active, or completed' USING ERRCODE = '23514';\n    END IF;\n    \n    -- Set ended_at if status is being changed to completed\n    IF p_status = 'completed' THEN\n        v_ended_at := CURRENT_TIMESTAMP;\n    END IF;\n    \n    -- Update session with provided values\n    UPDATE sessions \n    SET \n        topic = COALESCE(p_title, topic),\n        status = COALESCE(p_status, status),\n        ended_at = CASE WHEN p_status = 'completed' THEN v_ended_at ELSE ended_at END\n    WHERE session_id = p_session_id;\n    \n    -- Return updated session using get_session_by_id\n    RETURN QUERY\n    SELECT * FROM get_session_by_id(p_session_id);\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_user",
    "arguments": "p_user_id integer, p_email text, p_first_name text, p_last_name text, p_is_active boolean",
    "return_type": "TABLE(id integer, name text, email text, is_active boolean)",
    "definition": "CREATE OR REPLACE FUNCTION public.update_user(p_user_id integer, p_email text DEFAULT NULL::text, p_first_name text DEFAULT NULL::text, p_last_name text DEFAULT NULL::text, p_is_active boolean DEFAULT NULL::boolean)\n RETURNS TABLE(id integer, name text, email text, is_active boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_availability TEXT;\nBEGIN\n    -- Check if user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN\n        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';\n    END IF;\n    \n    -- Convert boolean to availability string\n    IF p_is_active IS NOT NULL THEN\n        v_availability := CASE WHEN p_is_active THEN 'available' ELSE 'offline' END;\n    END IF;\n    \n    -- Update user with provided values\n    UPDATE users \n    SET \n        email = COALESCE(p_email, email),\n        first_name = COALESCE(p_first_name, first_name),\n        last_name = COALESCE(p_last_name, last_name),\n        availability = COALESCE(v_availability, availability)\n    WHERE user_id = p_user_id;\n    \n    -- Return updated user\n    RETURN QUERY\n    SELECT \n        u.user_id::INTEGER as id,\n        COALESCE(\n            TRIM(CONCAT(u.first_name, ' ', u.last_name)), \n            u.email\n        ) as name,\n        u.email,\n        CASE WHEN u.availability = 'available' THEN true ELSE false END as is_active\n    FROM users u\n    WHERE u.user_id = p_user_id;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_user_last_seen",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION public.update_user_last_seen()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.last_seen = CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "public",
    "function_name": "update_user_presence",
    "arguments": "p_user_id integer, p_session_id integer, p_status character varying",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION public.update_user_presence(p_user_id integer, p_session_id integer, p_status character varying DEFAULT 'online'::character varying)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    INSERT INTO user_presence (user_id, session_id, status)\n    VALUES (p_user_id, p_session_id, p_status)\n    ON CONFLICT (user_id, session_id) \n    DO UPDATE SET status = p_status, last_seen = CURRENT_TIMESTAMP;\n    \n    RETURN TRUE;\nEND;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "apply_rls",
    "arguments": "wal jsonb, max_record_bytes integer",
    "return_type": "SETOF realtime.wal_rls",
    "definition": "CREATE OR REPLACE FUNCTION realtime.apply_rls(wal jsonb, max_record_bytes integer DEFAULT (1024 * 1024))\n RETURNS SETOF realtime.wal_rls\n LANGUAGE plpgsql\nAS $function$\ndeclare\n-- Regclass of the table e.g. public.notes\nentity_ regclass = (quote_ident(wal ->> 'schema') || '.' || quote_ident(wal ->> 'table'))::regclass;\n\n-- I, U, D, T: insert, update ...\naction realtime.action = (\n    case wal ->> 'action'\n        when 'I' then 'INSERT'\n        when 'U' then 'UPDATE'\n        when 'D' then 'DELETE'\n        else 'ERROR'\n    end\n);\n\n-- Is row level security enabled for the table\nis_rls_enabled bool = relrowsecurity from pg_class where oid = entity_;\n\nsubscriptions realtime.subscription[] = array_agg(subs)\n    from\n        realtime.subscription subs\n    where\n        subs.entity = entity_;\n\n-- Subscription vars\nroles regrole[] = array_agg(distinct us.claims_role::text)\n    from\n        unnest(subscriptions) us;\n\nworking_role regrole;\nclaimed_role regrole;\nclaims jsonb;\n\nsubscription_id uuid;\nsubscription_has_access bool;\nvisible_to_subscription_ids uuid[] = '{}';\n\n-- structured info for wal's columns\ncolumns realtime.wal_column[];\n-- previous identity values for update/delete\nold_columns realtime.wal_column[];\n\nerror_record_exceeds_max_size boolean = octet_length(wal::text) > max_record_bytes;\n\n-- Primary jsonb output for record\noutput jsonb;\n\nbegin\nperform set_config('role', null, true);\n\ncolumns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'columns') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nold_columns =\n    array_agg(\n        (\n            x->>'name',\n            x->>'type',\n            x->>'typeoid',\n            realtime.cast(\n                (x->'value') #>> '{}',\n                coalesce(\n                    (x->>'typeoid')::regtype, -- null when wal2json version <= 2.4\n                    (x->>'type')::regtype\n                )\n            ),\n            (pks ->> 'name') is not null,\n            true\n        )::realtime.wal_column\n    )\n    from\n        jsonb_array_elements(wal -> 'identity') x\n        left join jsonb_array_elements(wal -> 'pk') pks\n            on (x ->> 'name') = (pks ->> 'name');\n\nfor working_role in select * from unnest(roles) loop\n\n    -- Update `is_selectable` for columns and old_columns\n    columns =\n        array_agg(\n            (\n                c.name,\n                c.type_name,\n                c.type_oid,\n                c.value,\n                c.is_pkey,\n                pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n            )::realtime.wal_column\n        )\n        from\n            unnest(columns) c;\n\n    old_columns =\n            array_agg(\n                (\n                    c.name,\n                    c.type_name,\n                    c.type_oid,\n                    c.value,\n                    c.is_pkey,\n                    pg_catalog.has_column_privilege(working_role, entity_, c.name, 'SELECT')\n                )::realtime.wal_column\n            )\n            from\n                unnest(old_columns) c;\n\n    if action <> 'DELETE' and count(1) = 0 from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            -- subscriptions is already filtered by entity\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 400: Bad Request, no primary key']\n        )::realtime.wal_rls;\n\n    -- The claims role does not have SELECT permission to the primary key of entity\n    elsif action <> 'DELETE' and sum(c.is_selectable::int) <> count(1) from unnest(columns) c where c.is_pkey then\n        return next (\n            jsonb_build_object(\n                'schema', wal ->> 'schema',\n                'table', wal ->> 'table',\n                'type', action\n            ),\n            is_rls_enabled,\n            (select array_agg(s.subscription_id) from unnest(subscriptions) as s where claims_role = working_role),\n            array['Error 401: Unauthorized']\n        )::realtime.wal_rls;\n\n    else\n        output = jsonb_build_object(\n            'schema', wal ->> 'schema',\n            'table', wal ->> 'table',\n            'type', action,\n            'commit_timestamp', to_char(\n                ((wal ->> 'timestamp')::timestamptz at time zone 'utc'),\n                'YYYY-MM-DD\"T\"HH24:MI:SS.MS\"Z\"'\n            ),\n            'columns', (\n                select\n                    jsonb_agg(\n                        jsonb_build_object(\n                            'name', pa.attname,\n                            'type', pt.typname\n                        )\n                        order by pa.attnum asc\n                    )\n                from\n                    pg_attribute pa\n                    join pg_type pt\n                        on pa.atttypid = pt.oid\n                where\n                    attrelid = entity_\n                    and attnum > 0\n                    and pg_catalog.has_column_privilege(working_role, entity_, pa.attname, 'SELECT')\n            )\n        )\n        -- Add \"record\" key for insert and update\n        || case\n            when action in ('INSERT', 'UPDATE') then\n                jsonb_build_object(\n                    'record',\n                    (\n                        select\n                            jsonb_object_agg(\n                                -- if unchanged toast, get column name and value from old record\n                                coalesce((c).name, (oc).name),\n                                case\n                                    when (c).name is null then (oc).value\n                                    else (c).value\n                                end\n                            )\n                        from\n                            unnest(columns) c\n                            full outer join unnest(old_columns) oc\n                                on (c).name = (oc).name\n                        where\n                            coalesce((c).is_selectable, (oc).is_selectable)\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                    )\n                )\n            else '{}'::jsonb\n        end\n        -- Add \"old_record\" key for update and delete\n        || case\n            when action = 'UPDATE' then\n                jsonb_build_object(\n                        'old_record',\n                        (\n                            select jsonb_object_agg((c).name, (c).value)\n                            from unnest(old_columns) c\n                            where\n                                (c).is_selectable\n                                and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                        )\n                    )\n            when action = 'DELETE' then\n                jsonb_build_object(\n                    'old_record',\n                    (\n                        select jsonb_object_agg((c).name, (c).value)\n                        from unnest(old_columns) c\n                        where\n                            (c).is_selectable\n                            and ( not error_record_exceeds_max_size or (octet_length((c).value::text) <= 64))\n                            and ( not is_rls_enabled or (c).is_pkey ) -- if RLS enabled, we can't secure deletes so filter to pkey\n                    )\n                )\n            else '{}'::jsonb\n        end;\n\n        -- Create the prepared statement\n        if is_rls_enabled and action <> 'DELETE' then\n            if (select 1 from pg_prepared_statements where name = 'walrus_rls_stmt' limit 1) > 0 then\n                deallocate walrus_rls_stmt;\n            end if;\n            execute realtime.build_prepared_statement_sql('walrus_rls_stmt', entity_, columns);\n        end if;\n\n        visible_to_subscription_ids = '{}';\n\n        for subscription_id, claims in (\n                select\n                    subs.subscription_id,\n                    subs.claims\n                from\n                    unnest(subscriptions) subs\n                where\n                    subs.entity = entity_\n                    and subs.claims_role = working_role\n                    and (\n                        realtime.is_visible_through_filters(columns, subs.filters)\n                        or (\n                          action = 'DELETE'\n                          and realtime.is_visible_through_filters(old_columns, subs.filters)\n                        )\n                    )\n        ) loop\n\n            if not is_rls_enabled or action = 'DELETE' then\n                visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n            else\n                -- Check if RLS allows the role to see the record\n                perform\n                    -- Trim leading and trailing quotes from working_role because set_config\n                    -- doesn't recognize the role as valid if they are included\n                    set_config('role', trim(both '\"' from working_role::text), true),\n                    set_config('request.jwt.claims', claims::text, true);\n\n                execute 'execute walrus_rls_stmt' into subscription_has_access;\n\n                if subscription_has_access then\n                    visible_to_subscription_ids = visible_to_subscription_ids || subscription_id;\n                end if;\n            end if;\n        end loop;\n\n        perform set_config('role', null, true);\n\n        return next (\n            output,\n            is_rls_enabled,\n            visible_to_subscription_ids,\n            case\n                when error_record_exceeds_max_size then array['Error 413: Payload Too Large']\n                else '{}'\n            end\n        )::realtime.wal_rls;\n\n    end if;\nend loop;\n\nperform set_config('role', null, true);\nend;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "broadcast_changes",
    "arguments": "topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION realtime.broadcast_changes(topic_name text, event_name text, operation text, table_name text, table_schema text, new record, old record, level text DEFAULT 'ROW'::text)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    -- Declare a variable to hold the JSONB representation of the row\n    row_data jsonb := '{}'::jsonb;\nBEGIN\n    IF level = 'STATEMENT' THEN\n        RAISE EXCEPTION 'function can only be triggered for each row, not for each statement';\n    END IF;\n    -- Check the operation type and handle accordingly\n    IF operation = 'INSERT' OR operation = 'UPDATE' OR operation = 'DELETE' THEN\n        row_data := jsonb_build_object('old_record', OLD, 'record', NEW, 'operation', operation, 'table', table_name, 'schema', table_schema);\n        PERFORM realtime.send (row_data, event_name, topic_name);\n    ELSE\n        RAISE EXCEPTION 'Unexpected operation type: %', operation;\n    END IF;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE EXCEPTION 'Failed to process the row: %', SQLERRM;\nEND;\n\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "build_prepared_statement_sql",
    "arguments": "prepared_statement_name text, entity regclass, columns realtime.wal_column[]",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION realtime.build_prepared_statement_sql(prepared_statement_name text, entity regclass, columns realtime.wal_column[])\n RETURNS text\n LANGUAGE sql\nAS $function$\n      /*\n      Builds a sql string that, if executed, creates a prepared statement to\n      tests retrive a row from *entity* by its primary key columns.\n      Example\n          select realtime.build_prepared_statement_sql('public.notes', '{\"id\"}'::text[], '{\"bigint\"}'::text[])\n      */\n          select\n      'prepare ' || prepared_statement_name || ' as\n          select\n              exists(\n                  select\n                      1\n                  from\n                      ' || entity || '\n                  where\n                      ' || string_agg(quote_ident(pkc.name) || '=' || quote_nullable(pkc.value #>> '{}') , ' and ') || '\n              )'\n          from\n              unnest(columns) pkc\n          where\n              pkc.is_pkey\n          group by\n              entity\n      $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "cast",
    "arguments": "val text, type_ regtype",
    "return_type": "jsonb",
    "definition": "CREATE OR REPLACE FUNCTION realtime.\"cast\"(val text, type_ regtype)\n RETURNS jsonb\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n    declare\n      res jsonb;\n    begin\n      execute format('select to_jsonb(%L::'|| type_::text || ')', val)  into res;\n      return res;\n    end\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "check_equality_op",
    "arguments": "op realtime.equality_op, type_ regtype, val_1 text, val_2 text",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION realtime.check_equality_op(op realtime.equality_op, type_ regtype, val_1 text, val_2 text)\n RETURNS boolean\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\n      /*\n      Casts *val_1* and *val_2* as type *type_* and check the *op* condition for truthiness\n      */\n      declare\n          op_symbol text = (\n              case\n                  when op = 'eq' then '='\n                  when op = 'neq' then '!='\n                  when op = 'lt' then '<'\n                  when op = 'lte' then '<='\n                  when op = 'gt' then '>'\n                  when op = 'gte' then '>='\n                  when op = 'in' then '= any'\n                  else 'UNKNOWN OP'\n              end\n          );\n          res boolean;\n      begin\n          execute format(\n              'select %L::'|| type_::text || ' ' || op_symbol\n              || ' ( %L::'\n              || (\n                  case\n                      when op = 'in' then type_::text || '[]'\n                      else type_::text end\n              )\n              || ')', val_1, val_2) into res;\n          return res;\n      end;\n      $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "is_visible_through_filters",
    "arguments": "columns realtime.wal_column[], filters realtime.user_defined_filter[]",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION realtime.is_visible_through_filters(columns realtime.wal_column[], filters realtime.user_defined_filter[])\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n    /*\n    Should the record be visible (true) or filtered out (false) after *filters* are applied\n    */\n        select\n            -- Default to allowed when no filters present\n            $2 is null -- no filters. this should not happen because subscriptions has a default\n            or array_length($2, 1) is null -- array length of an empty array is null\n            or bool_and(\n                coalesce(\n                    realtime.check_equality_op(\n                        op:=f.op,\n                        type_:=coalesce(\n                            col.type_oid::regtype, -- null when wal2json version <= 2.4\n                            col.type_name::regtype\n                        ),\n                        -- cast jsonb to text\n                        val_1:=col.value #>> '{}',\n                        val_2:=f.value\n                    ),\n                    false -- if null, filter does not match\n                )\n            )\n        from\n            unnest(filters) f\n            join unnest(columns) col\n                on f.column_name = col.name;\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "list_changes",
    "arguments": "publication name, slot_name name, max_changes integer, max_record_bytes integer",
    "return_type": "SETOF realtime.wal_rls",
    "definition": "CREATE OR REPLACE FUNCTION realtime.list_changes(publication name, slot_name name, max_changes integer, max_record_bytes integer)\n RETURNS SETOF realtime.wal_rls\n LANGUAGE sql\n SET log_min_messages TO 'fatal'\nAS $function$\n      with pub as (\n        select\n          concat_ws(\n            ',',\n            case when bool_or(pubinsert) then 'insert' else null end,\n            case when bool_or(pubupdate) then 'update' else null end,\n            case when bool_or(pubdelete) then 'delete' else null end\n          ) as w2j_actions,\n          coalesce(\n            string_agg(\n              realtime.quote_wal2json(format('%I.%I', schemaname, tablename)::regclass),\n              ','\n            ) filter (where ppt.tablename is not null and ppt.tablename not like '% %'),\n            ''\n          ) w2j_add_tables\n        from\n          pg_publication pp\n          left join pg_publication_tables ppt\n            on pp.pubname = ppt.pubname\n        where\n          pp.pubname = publication\n        group by\n          pp.pubname\n        limit 1\n      ),\n      w2j as (\n        select\n          x.*, pub.w2j_add_tables\n        from\n          pub,\n          pg_logical_slot_get_changes(\n            slot_name, null, max_changes,\n            'include-pk', 'true',\n            'include-transaction', 'false',\n            'include-timestamp', 'true',\n            'include-type-oids', 'true',\n            'format-version', '2',\n            'actions', pub.w2j_actions,\n            'add-tables', pub.w2j_add_tables\n          ) x\n      )\n      select\n        xyz.wal,\n        xyz.is_rls_enabled,\n        xyz.subscription_ids,\n        xyz.errors\n      from\n        w2j,\n        realtime.apply_rls(\n          wal := w2j.data::jsonb,\n          max_record_bytes := max_record_bytes\n        ) xyz(wal, is_rls_enabled, subscription_ids, errors)\n      where\n        w2j.w2j_add_tables <> ''\n        and xyz.subscription_ids[1] is not null\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "quote_wal2json",
    "arguments": "entity regclass",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION realtime.quote_wal2json(entity regclass)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\n      select\n        (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(nsp.nspname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n        )\n        || '.'\n        || (\n          select string_agg('' || ch,'')\n          from unnest(string_to_array(pc.relname::text, null)) with ordinality x(ch, idx)\n          where\n            not (x.idx = 1 and x.ch = '\"')\n            and not (\n              x.idx = array_length(string_to_array(nsp.nspname::text, null), 1)\n              and x.ch = '\"'\n            )\n          )\n      from\n        pg_class pc\n        join pg_namespace nsp\n          on pc.relnamespace = nsp.oid\n      where\n        pc.oid = entity\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "send",
    "arguments": "payload jsonb, event text, topic text, private boolean",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION realtime.send(payload jsonb, event text, topic text, private boolean DEFAULT true)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  BEGIN\n    -- Set the topic configuration\n    EXECUTE format('SET LOCAL realtime.topic TO %L', topic);\n\n    -- Attempt to insert the message\n    INSERT INTO realtime.messages (payload, event, topic, private, extension)\n    VALUES (payload, event, topic, private, 'broadcast');\n  EXCEPTION\n    WHEN OTHERS THEN\n      -- Capture and notify the error\n      RAISE WARNING 'ErrorSendingBroadcastMessage: %', SQLERRM;\n  END;\nEND;\n$function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "subscription_check_filters",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION realtime.subscription_check_filters()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\n    /*\n    Validates that the user defined filters for a subscription:\n    - refer to valid columns that the claimed role may access\n    - values are coercable to the correct column type\n    */\n    declare\n        col_names text[] = coalesce(\n                array_agg(c.column_name order by c.ordinal_position),\n                '{}'::text[]\n            )\n            from\n                information_schema.columns c\n            where\n                format('%I.%I', c.table_schema, c.table_name)::regclass = new.entity\n                and pg_catalog.has_column_privilege(\n                    (new.claims ->> 'role'),\n                    format('%I.%I', c.table_schema, c.table_name)::regclass,\n                    c.column_name,\n                    'SELECT'\n                );\n        filter realtime.user_defined_filter;\n        col_type regtype;\n\n        in_val jsonb;\n    begin\n        for filter in select * from unnest(new.filters) loop\n            -- Filtered column is valid\n            if not filter.column_name = any(col_names) then\n                raise exception 'invalid column for filter %', filter.column_name;\n            end if;\n\n            -- Type is sanitized and safe for string interpolation\n            col_type = (\n                select atttypid::regtype\n                from pg_catalog.pg_attribute\n                where attrelid = new.entity\n                      and attname = filter.column_name\n            );\n            if col_type is null then\n                raise exception 'failed to lookup type for column %', filter.column_name;\n            end if;\n\n            -- Set maximum number of entries for in filter\n            if filter.op = 'in'::realtime.equality_op then\n                in_val = realtime.cast(filter.value, (col_type::text || '[]')::regtype);\n                if coalesce(jsonb_array_length(in_val), 0) > 100 then\n                    raise exception 'too many values for `in` filter. Maximum 100';\n                end if;\n            else\n                -- raises an exception if value is not coercable to type\n                perform realtime.cast(filter.value, col_type);\n            end if;\n\n        end loop;\n\n        -- Apply consistent order to filters so the unique constraint on\n        -- (subscription_id, entity, filters) can't be tricked by a different filter order\n        new.filters = coalesce(\n            array_agg(f order by f.column_name, f.op, f.value),\n            '{}'\n        ) from unnest(new.filters) f;\n\n        return new;\n    end;\n    $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "to_regrole",
    "arguments": "role_name text",
    "return_type": "regrole",
    "definition": "CREATE OR REPLACE FUNCTION realtime.to_regrole(role_name text)\n RETURNS regrole\n LANGUAGE sql\n IMMUTABLE\nAS $function$ select role_name::regrole $function$\n"
  },
  {
    "schema": "realtime",
    "function_name": "topic",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION realtime.topic()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect nullif(current_setting('realtime.topic', true), '')::text;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "add_prefixes",
    "arguments": "_bucket_id text, _name text",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION storage.add_prefixes(_bucket_id text, _name text)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    prefixes text[];\nBEGIN\n    prefixes := \"storage\".\"get_prefixes\"(\"_name\");\n\n    IF array_length(prefixes, 1) > 0 THEN\n        INSERT INTO storage.prefixes (name, bucket_id)\n        SELECT UNNEST(prefixes) as name, \"_bucket_id\" ON CONFLICT DO NOTHING;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "can_insert_object",
    "arguments": "bucketid text, name text, owner uuid, metadata jsonb",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION storage.can_insert_object(bucketid text, name text, owner uuid, metadata jsonb)\n RETURNS void\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  INSERT INTO \"storage\".\"objects\" (\"bucket_id\", \"name\", \"owner\", \"metadata\") VALUES (bucketid, name, owner, metadata);\n  -- hack to rollback the successful insert\n  RAISE sqlstate 'PT200' using\n  message = 'ROLLBACK',\n  detail = 'rollback successful insert';\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_leaf_prefixes",
    "arguments": "bucket_ids text[], names text[]",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION storage.delete_leaf_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_rows_deleted integer;\nBEGIN\n    LOOP\n        WITH candidates AS (\n            SELECT DISTINCT\n                t.bucket_id,\n                unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        ),\n        uniq AS (\n             SELECT\n                 bucket_id,\n                 name,\n                 storage.get_level(name) AS level\n             FROM candidates\n             WHERE name <> ''\n             GROUP BY bucket_id, name\n        ),\n        leaf AS (\n             SELECT\n                 p.bucket_id,\n                 p.name,\n                 p.level\n             FROM storage.prefixes AS p\n                  JOIN uniq AS u\n                       ON u.bucket_id = p.bucket_id\n                           AND u.name = p.name\n                           AND u.level = p.level\n             WHERE NOT EXISTS (\n                 SELECT 1\n                 FROM storage.objects AS o\n                 WHERE o.bucket_id = p.bucket_id\n                   AND o.level = p.level + 1\n                   AND o.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n             AND NOT EXISTS (\n                 SELECT 1\n                 FROM storage.prefixes AS c\n                 WHERE c.bucket_id = p.bucket_id\n                   AND c.level = p.level + 1\n                   AND c.name COLLATE \"C\" LIKE p.name || '/%'\n             )\n        )\n        DELETE\n        FROM storage.prefixes AS p\n            USING leaf AS l\n        WHERE p.bucket_id = l.bucket_id\n          AND p.name = l.name\n          AND p.level = l.level;\n\n        GET DIAGNOSTICS v_rows_deleted = ROW_COUNT;\n        EXIT WHEN v_rows_deleted = 0;\n    END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_prefix",
    "arguments": "_bucket_id text, _name text",
    "return_type": "boolean",
    "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix(_bucket_id text, _name text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n    -- Check if we can delete the prefix\n    IF EXISTS(\n        SELECT FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"prefixes\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    )\n    OR EXISTS(\n        SELECT FROM \"storage\".\"objects\"\n        WHERE \"objects\".\"bucket_id\" = \"_bucket_id\"\n          AND \"storage\".\"get_level\"(\"objects\".\"name\") = \"storage\".\"get_level\"(\"_name\") + 1\n          AND \"objects\".\"name\" COLLATE \"C\" LIKE \"_name\" || '/%'\n        LIMIT 1\n    ) THEN\n    -- There are sub-objects, skip deletion\n    RETURN false;\n    ELSE\n        DELETE FROM \"storage\".\"prefixes\"\n        WHERE \"prefixes\".\"bucket_id\" = \"_bucket_id\"\n          AND level = \"storage\".\"get_level\"(\"_name\")\n          AND \"prefixes\".\"name\" = \"_name\";\n        RETURN true;\n    END IF;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "delete_prefix_hierarchy_trigger",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.delete_prefix_hierarchy_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    prefix text;\nBEGIN\n    prefix := \"storage\".\"get_prefix\"(OLD.\"name\");\n\n    IF coalesce(prefix, '') != '' THEN\n        PERFORM \"storage\".\"delete_prefix\"(OLD.\"bucket_id\", prefix);\n    END IF;\n\n    RETURN OLD;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "enforce_bucket_name_length",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.enforce_bucket_name_length()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n    if length(new.name) > 100 then\n        raise exception 'bucket name \"%\" is too long (% characters). Max is 100.', new.name, length(new.name);\n    end if;\n    return new;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "extension",
    "arguments": "name text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION storage.extension(name text)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\n    _filename text;\nBEGIN\n    SELECT string_to_array(name, '/') INTO _parts;\n    SELECT _parts[array_length(_parts,1)] INTO _filename;\n    RETURN reverse(split_part(reverse(_filename), '.', 1));\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "filename",
    "arguments": "name text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION storage.filename(name text)\n RETURNS text\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n_parts text[];\nBEGIN\n\tselect string_to_array(name, '/') into _parts;\n\treturn _parts[array_length(_parts,1)];\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "foldername",
    "arguments": "name text",
    "return_type": "text[]",
    "definition": "CREATE OR REPLACE FUNCTION storage.foldername(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\nDECLARE\n    _parts text[];\nBEGIN\n    -- Split on \"/\" to get path segments\n    SELECT string_to_array(name, '/') INTO _parts;\n    -- Return everything except the last segment\n    RETURN _parts[1 : array_length(_parts,1) - 1];\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_level",
    "arguments": "name text",
    "return_type": "integer",
    "definition": "CREATE OR REPLACE FUNCTION storage.get_level(name text)\n RETURNS integer\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT array_length(string_to_array(\"name\", '/'), 1);\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_prefix",
    "arguments": "name text",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION storage.get_prefix(name text)\n RETURNS text\n LANGUAGE sql\n IMMUTABLE STRICT\nAS $function$\nSELECT\n    CASE WHEN strpos(\"name\", '/') > 0 THEN\n             regexp_replace(\"name\", '[\\/]{1}[^\\/]+\\/?$', '')\n         ELSE\n             ''\n        END;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_prefixes",
    "arguments": "name text",
    "return_type": "text[]",
    "definition": "CREATE OR REPLACE FUNCTION storage.get_prefixes(name text)\n RETURNS text[]\n LANGUAGE plpgsql\n IMMUTABLE STRICT\nAS $function$\nDECLARE\n    parts text[];\n    prefixes text[];\n    prefix text;\nBEGIN\n    -- Split the name into parts by '/'\n    parts := string_to_array(\"name\", '/');\n    prefixes := '{}';\n\n    -- Construct the prefixes, stopping one level below the last part\n    FOR i IN 1..array_length(parts, 1) - 1 LOOP\n            prefix := array_to_string(parts[1:i], '/');\n            prefixes := array_append(prefixes, prefix);\n    END LOOP;\n\n    RETURN prefixes;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "get_size_by_bucket",
    "arguments": "",
    "return_type": "TABLE(size bigint, bucket_id text)",
    "definition": "CREATE OR REPLACE FUNCTION storage.get_size_by_bucket()\n RETURNS TABLE(size bigint, bucket_id text)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    return query\n        select sum((metadata->>'size')::bigint) as size, obj.bucket_id\n        from \"storage\".objects as obj\n        group by obj.bucket_id;\nEND\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "list_multipart_uploads_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, next_key_token text, next_upload_token text",
    "return_type": "TABLE(key text, id text, created_at timestamp with time zone)",
    "definition": "CREATE OR REPLACE FUNCTION storage.list_multipart_uploads_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, next_key_token text DEFAULT ''::text, next_upload_token text DEFAULT ''::text)\n RETURNS TABLE(key text, id text, created_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(key COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                        substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1)))\n                    ELSE\n                        key\n                END AS key, id, created_at\n            FROM\n                storage.s3_multipart_uploads\n            WHERE\n                bucket_id = $5 AND\n                key ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $4 != '''' AND $6 = '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(key from length($1) + 1)) > 0 THEN\n                                substring(key from 1 for length($1) + position($2 IN substring(key from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                key COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END AND\n                CASE\n                    WHEN $6 != '''' THEN\n                        id COLLATE \"C\" > $6\n                    ELSE\n                        true\n                    END\n            ORDER BY\n                key COLLATE \"C\" ASC, created_at ASC) as e order by key COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_key_token, bucket_id, next_upload_token;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "list_objects_with_delimiter",
    "arguments": "bucket_id text, prefix_param text, delimiter_param text, max_keys integer, start_after text, next_token text",
    "return_type": "TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)",
    "definition": "CREATE OR REPLACE FUNCTION storage.list_objects_with_delimiter(bucket_id text, prefix_param text, delimiter_param text, max_keys integer DEFAULT 100, start_after text DEFAULT ''::text, next_token text DEFAULT ''::text)\n RETURNS TABLE(name text, id uuid, metadata jsonb, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RETURN QUERY EXECUTE\n        'SELECT DISTINCT ON(name COLLATE \"C\") * from (\n            SELECT\n                CASE\n                    WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                        substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1)))\n                    ELSE\n                        name\n                END AS name, id, metadata, updated_at\n            FROM\n                storage.objects\n            WHERE\n                bucket_id = $5 AND\n                name ILIKE $1 || ''%'' AND\n                CASE\n                    WHEN $6 != '''' THEN\n                    name COLLATE \"C\" > $6\n                ELSE true END\n                AND CASE\n                    WHEN $4 != '''' THEN\n                        CASE\n                            WHEN position($2 IN substring(name from length($1) + 1)) > 0 THEN\n                                substring(name from 1 for length($1) + position($2 IN substring(name from length($1) + 1))) COLLATE \"C\" > $4\n                            ELSE\n                                name COLLATE \"C\" > $4\n                            END\n                    ELSE\n                        true\n                END\n            ORDER BY\n                name COLLATE \"C\" ASC) as e order by name COLLATE \"C\" LIMIT $3'\n        USING prefix_param, delimiter_param, max_keys, next_token, bucket_id, start_after;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "lock_top_prefixes",
    "arguments": "bucket_ids text[], names text[]",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION storage.lock_top_prefixes(bucket_ids text[], names text[])\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket text;\n    v_top text;\nBEGIN\n    FOR v_bucket, v_top IN\n        SELECT DISTINCT t.bucket_id,\n            split_part(t.name, '/', 1) AS top\n        FROM unnest(bucket_ids, names) AS t(bucket_id, name)\n        WHERE t.name <> ''\n        ORDER BY 1, 2\n        LOOP\n            PERFORM pg_advisory_xact_lock(hashtextextended(v_bucket || '/' || v_top, 0));\n        END LOOP;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_delete_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.objects_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_insert_prefix_trigger",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.objects_insert_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    NEW.level := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    -- NEW - OLD (destinations to create prefixes for)\n    v_add_bucket_ids text[];\n    v_add_names      text[];\n\n    -- OLD - NEW (sources to prune)\n    v_src_bucket_ids text[];\n    v_src_names      text[];\nBEGIN\n    IF TG_OP <> 'UPDATE' THEN\n        RETURN NULL;\n    END IF;\n\n    -- 1) Compute NEWOLD (added paths) and OLDNEW (moved-away paths)\n    WITH added AS (\n        SELECT n.bucket_id, n.name\n        FROM new_rows n\n        WHERE n.name <> '' AND position('/' in n.name) > 0\n        EXCEPT\n        SELECT o.bucket_id, o.name FROM old_rows o WHERE o.name <> ''\n    ),\n    moved AS (\n         SELECT o.bucket_id, o.name\n         FROM old_rows o\n         WHERE o.name <> ''\n         EXCEPT\n         SELECT n.bucket_id, n.name FROM new_rows n WHERE n.name <> ''\n    )\n    SELECT\n        -- arrays for ADDED (dest) in stable order\n        COALESCE( (SELECT array_agg(a.bucket_id ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        COALESCE( (SELECT array_agg(a.name      ORDER BY a.bucket_id, a.name) FROM added a), '{}' ),\n        -- arrays for MOVED (src) in stable order\n        COALESCE( (SELECT array_agg(m.bucket_id ORDER BY m.bucket_id, m.name) FROM moved m), '{}' ),\n        COALESCE( (SELECT array_agg(m.name      ORDER BY m.bucket_id, m.name) FROM moved m), '{}' )\n    INTO v_add_bucket_ids, v_add_names, v_src_bucket_ids, v_src_names;\n\n    -- Nothing to do?\n    IF (array_length(v_add_bucket_ids, 1) IS NULL) AND (array_length(v_src_bucket_ids, 1) IS NULL) THEN\n        RETURN NULL;\n    END IF;\n\n    -- 2) Take per-(bucket, top) locks: ALL prefixes in consistent global order to prevent deadlocks\n    DECLARE\n        v_all_bucket_ids text[];\n        v_all_names text[];\n    BEGIN\n        -- Combine source and destination arrays for consistent lock ordering\n        v_all_bucket_ids := COALESCE(v_src_bucket_ids, '{}') || COALESCE(v_add_bucket_ids, '{}');\n        v_all_names := COALESCE(v_src_names, '{}') || COALESCE(v_add_names, '{}');\n\n        -- Single lock call ensures consistent global ordering across all transactions\n        IF array_length(v_all_bucket_ids, 1) IS NOT NULL THEN\n            PERFORM storage.lock_top_prefixes(v_all_bucket_ids, v_all_names);\n        END IF;\n    END;\n\n    -- 3) Create destination prefixes (NEWOLD) BEFORE pruning sources\n    IF array_length(v_add_bucket_ids, 1) IS NOT NULL THEN\n        WITH candidates AS (\n            SELECT DISTINCT t.bucket_id, unnest(storage.get_prefixes(t.name)) AS name\n            FROM unnest(v_add_bucket_ids, v_add_names) AS t(bucket_id, name)\n            WHERE name <> ''\n        )\n        INSERT INTO storage.prefixes (bucket_id, name)\n        SELECT c.bucket_id, c.name\n        FROM candidates c\n        ON CONFLICT DO NOTHING;\n    END IF;\n\n    -- 4) Prune source prefixes bottom-up for OLDNEW\n    IF array_length(v_src_bucket_ids, 1) IS NOT NULL THEN\n        -- re-entrancy guard so DELETE on prefixes won't recurse\n        IF current_setting('storage.gc.prefixes', true) <> '1' THEN\n            PERFORM set_config('storage.gc.prefixes', '1', true);\n        END IF;\n\n        PERFORM storage.delete_leaf_prefixes(v_src_bucket_ids, v_src_names);\n    END IF;\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_level_trigger",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_level_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Set the new level\n        NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n    END IF;\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "objects_update_prefix_trigger",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.objects_update_prefix_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n    old_prefixes TEXT[];\nBEGIN\n    -- Ensure this is an update operation and the name has changed\n    IF TG_OP = 'UPDATE' AND (NEW.\"name\" <> OLD.\"name\" OR NEW.\"bucket_id\" <> OLD.\"bucket_id\") THEN\n        -- Retrieve old prefixes\n        old_prefixes := \"storage\".\"get_prefixes\"(OLD.\"name\");\n\n        -- Remove old prefixes that are only used by this object\n        WITH all_prefixes as (\n            SELECT unnest(old_prefixes) as prefix\n        ),\n        can_delete_prefixes as (\n             SELECT prefix\n             FROM all_prefixes\n             WHERE NOT EXISTS (\n                 SELECT 1 FROM \"storage\".\"objects\"\n                 WHERE \"bucket_id\" = OLD.\"bucket_id\"\n                   AND \"name\" <> OLD.\"name\"\n                   AND \"name\" LIKE (prefix || '%')\n             )\n         )\n        DELETE FROM \"storage\".\"prefixes\" WHERE name IN (SELECT prefix FROM can_delete_prefixes);\n\n        -- Add new prefixes\n        PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    END IF;\n    -- Set the new level\n    NEW.\"level\" := \"storage\".\"get_level\"(NEW.\"name\");\n\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "operation",
    "arguments": "",
    "return_type": "text",
    "definition": "CREATE OR REPLACE FUNCTION storage.operation()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n    RETURN current_setting('storage.operation', true);\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "prefixes_delete_cleanup",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_delete_cleanup()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    v_bucket_ids text[];\n    v_names      text[];\nBEGIN\n    IF current_setting('storage.gc.prefixes', true) = '1' THEN\n        RETURN NULL;\n    END IF;\n\n    PERFORM set_config('storage.gc.prefixes', '1', true);\n\n    SELECT COALESCE(array_agg(d.bucket_id), '{}'),\n           COALESCE(array_agg(d.name), '{}')\n    INTO v_bucket_ids, v_names\n    FROM deleted AS d\n    WHERE d.name <> '';\n\n    PERFORM storage.lock_top_prefixes(v_bucket_ids, v_names);\n    PERFORM storage.delete_leaf_prefixes(v_bucket_ids, v_names);\n\n    RETURN NULL;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "prefixes_insert_trigger",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.prefixes_insert_trigger()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    PERFORM \"storage\".\"add_prefixes\"(NEW.\"bucket_id\", NEW.\"name\");\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION storage.search(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\nAS $function$\ndeclare\n    can_bypass_rls BOOLEAN;\nbegin\n    SELECT rolbypassrls\n    INTO can_bypass_rls\n    FROM pg_roles\n    WHERE rolname = coalesce(nullif(current_setting('role', true), 'none'), current_user);\n\n    IF can_bypass_rls THEN\n        RETURN QUERY SELECT * FROM storage.search_v1_optimised(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    ELSE\n        RETURN QUERY SELECT * FROM storage.search_legacy_v1(prefix, bucketname, limits, levels, offsets, search, sortcolumn, sortorder);\n    END IF;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_legacy_v1",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION storage.search_legacy_v1(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select path_tokens[$1] as folder\n           from storage.objects\n             where objects.name ilike $2 || $3 || ''%''\n               and bucket_id = $4\n               and array_length(objects.path_tokens, 1) <> $1\n           group by folder\n           order by folder ' || v_sort_order || '\n     )\n     (select folder as \"name\",\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[$1] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where objects.name ilike $2 || $3 || ''%''\n       and bucket_id = $4\n       and array_length(objects.path_tokens, 1) = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_v1_optimised",
    "arguments": "prefix text, bucketname text, limits integer, levels integer, offsets integer, search text, sortcolumn text, sortorder text",
    "return_type": "TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION storage.search_v1_optimised(prefix text, bucketname text, limits integer DEFAULT 100, levels integer DEFAULT 1, offsets integer DEFAULT 0, search text DEFAULT ''::text, sortcolumn text DEFAULT 'name'::text, sortorder text DEFAULT 'asc'::text)\n RETURNS TABLE(name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\ndeclare\n    v_order_by text;\n    v_sort_order text;\nbegin\n    case\n        when sortcolumn = 'name' then\n            v_order_by = 'name';\n        when sortcolumn = 'updated_at' then\n            v_order_by = 'updated_at';\n        when sortcolumn = 'created_at' then\n            v_order_by = 'created_at';\n        when sortcolumn = 'last_accessed_at' then\n            v_order_by = 'last_accessed_at';\n        else\n            v_order_by = 'name';\n        end case;\n\n    case\n        when sortorder = 'asc' then\n            v_sort_order = 'asc';\n        when sortorder = 'desc' then\n            v_sort_order = 'desc';\n        else\n            v_sort_order = 'asc';\n        end case;\n\n    v_order_by = v_order_by || ' ' || v_sort_order;\n\n    return query execute\n        'with folders as (\n           select (string_to_array(name, ''/''))[level] as name\n           from storage.prefixes\n             where lower(prefixes.name) like lower($2 || $3) || ''%''\n               and bucket_id = $4\n               and level = $1\n           order by name ' || v_sort_order || '\n     )\n     (select name,\n            null as id,\n            null as updated_at,\n            null as created_at,\n            null as last_accessed_at,\n            null as metadata from folders)\n     union all\n     (select path_tokens[level] as \"name\",\n            id,\n            updated_at,\n            created_at,\n            last_accessed_at,\n            metadata\n     from storage.objects\n     where lower(objects.name) like lower($2 || $3) || ''%''\n       and bucket_id = $4\n       and level = $1\n     order by ' || v_order_by || ')\n     limit $5\n     offset $6' using levels, prefix, search, bucketname, limits, offsets;\nend;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "search_v2",
    "arguments": "prefix text, bucket_name text, limits integer, levels integer, start_after text, sort_order text, sort_column text, sort_column_after text",
    "return_type": "TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)",
    "definition": "CREATE OR REPLACE FUNCTION storage.search_v2(prefix text, bucket_name text, limits integer DEFAULT 100, levels integer DEFAULT 1, start_after text DEFAULT ''::text, sort_order text DEFAULT 'asc'::text, sort_column text DEFAULT 'name'::text, sort_column_after text DEFAULT ''::text)\n RETURNS TABLE(key text, name text, id uuid, updated_at timestamp with time zone, created_at timestamp with time zone, last_accessed_at timestamp with time zone, metadata jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    sort_col text;\n    sort_ord text;\n    cursor_op text;\n    cursor_expr text;\n    sort_expr text;\nBEGIN\n    -- Validate sort_order\n    sort_ord := lower(sort_order);\n    IF sort_ord NOT IN ('asc', 'desc') THEN\n        sort_ord := 'asc';\n    END IF;\n\n    -- Determine cursor comparison operator\n    IF sort_ord = 'asc' THEN\n        cursor_op := '>';\n    ELSE\n        cursor_op := '<';\n    END IF;\n    \n    sort_col := lower(sort_column);\n    -- Validate sort column  \n    IF sort_col IN ('updated_at', 'created_at') THEN\n        cursor_expr := format(\n            '($5 = '''' OR ROW(date_trunc(''milliseconds'', %I), name COLLATE \"C\") %s ROW(COALESCE(NULLIF($6, '''')::timestamptz, ''epoch''::timestamptz), $5))',\n            sort_col, cursor_op\n        );\n        sort_expr := format(\n            'COALESCE(date_trunc(''milliseconds'', %I), ''epoch''::timestamptz) %s, name COLLATE \"C\" %s',\n            sort_col, sort_ord, sort_ord\n        );\n    ELSE\n        cursor_expr := format('($5 = '''' OR name COLLATE \"C\" %s $5)', cursor_op);\n        sort_expr := format('name COLLATE \"C\" %s', sort_ord);\n    END IF;\n\n    RETURN QUERY EXECUTE format(\n        $sql$\n        SELECT * FROM (\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    NULL::uuid AS id,\n                    updated_at,\n                    created_at,\n                    NULL::timestamptz AS last_accessed_at,\n                    NULL::jsonb AS metadata\n                FROM storage.prefixes\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n            UNION ALL\n            (\n                SELECT\n                    split_part(name, '/', $4) AS key,\n                    name,\n                    id,\n                    updated_at,\n                    created_at,\n                    last_accessed_at,\n                    metadata\n                FROM storage.objects\n                WHERE name COLLATE \"C\" LIKE $1 || '%%'\n                    AND bucket_id = $2\n                    AND level = $4\n                    AND %s\n                ORDER BY %s\n                LIMIT $3\n            )\n        ) obj\n        ORDER BY %s\n        LIMIT $3\n        $sql$,\n        cursor_expr,    -- prefixes WHERE\n        sort_expr,      -- prefixes ORDER BY\n        cursor_expr,    -- objects WHERE\n        sort_expr,      -- objects ORDER BY\n        sort_expr       -- final ORDER BY\n    )\n    USING prefix, bucket_name, limits, levels, start_after, sort_column_after;\nEND;\n$function$\n"
  },
  {
    "schema": "storage",
    "function_name": "update_updated_at_column",
    "arguments": "",
    "return_type": "trigger",
    "definition": "CREATE OR REPLACE FUNCTION storage.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW; \nEND;\n$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_decrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_decrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_decrypt_by_id$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_encrypt",
    "arguments": "message bytea, additional bytea, key_id bigint, context bytea, nonce bytea",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_encrypt(message bytea, additional bytea, key_id bigint, context bytea DEFAULT '\\x7067736f6469756d'::bytea, nonce bytea DEFAULT NULL::bytea)\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_encrypt_by_id$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "_crypto_aead_det_noncegen",
    "arguments": "",
    "return_type": "bytea",
    "definition": "CREATE OR REPLACE FUNCTION vault._crypto_aead_det_noncegen()\n RETURNS bytea\n LANGUAGE c\n IMMUTABLE\nAS '$libdir/supabase_vault', $function$pgsodium_crypto_aead_det_noncegen$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "create_secret",
    "arguments": "new_secret text, new_name text, new_description text, new_key_id uuid",
    "return_type": "uuid",
    "definition": "CREATE OR REPLACE FUNCTION vault.create_secret(new_secret text, new_name text DEFAULT NULL::text, new_description text DEFAULT ''::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  rec record;\nBEGIN\n  INSERT INTO vault.secrets (secret, name, description)\n  VALUES (\n    new_secret,\n    new_name,\n    new_description\n  )\n  RETURNING * INTO rec;\n  UPDATE vault.secrets s\n  SET secret = encode(vault._crypto_aead_det_encrypt(\n    message := convert_to(rec.secret, 'utf8'),\n    additional := convert_to(s.id::text, 'utf8'),\n    key_id := 0,\n    context := 'pgsodium'::bytea,\n    nonce := rec.nonce\n  ), 'base64')\n  WHERE id = rec.id;\n  RETURN rec.id;\nEND\n$function$\n"
  },
  {
    "schema": "vault",
    "function_name": "update_secret",
    "arguments": "secret_id uuid, new_secret text, new_name text, new_description text, new_key_id uuid",
    "return_type": "void",
    "definition": "CREATE OR REPLACE FUNCTION vault.update_secret(secret_id uuid, new_secret text DEFAULT NULL::text, new_name text DEFAULT NULL::text, new_description text DEFAULT NULL::text, new_key_id uuid DEFAULT NULL::uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO ''\nAS $function$\nDECLARE\n  decrypted_secret text := (SELECT decrypted_secret FROM vault.decrypted_secrets WHERE id = secret_id);\nBEGIN\n  UPDATE vault.secrets s\n  SET\n    secret = CASE WHEN new_secret IS NULL THEN s.secret\n                  ELSE encode(vault._crypto_aead_det_encrypt(\n                    message := convert_to(new_secret, 'utf8'),\n                    additional := convert_to(s.id::text, 'utf8'),\n                    key_id := 0,\n                    context := 'pgsodium'::bytea,\n                    nonce := s.nonce\n                  ), 'base64') END,\n    name = coalesce(new_name, s.name),\n    description = coalesce(new_description, s.description),\n    updated_at = now()\n  WHERE s.id = secret_id;\nEND\n$function$\n"
  }
]