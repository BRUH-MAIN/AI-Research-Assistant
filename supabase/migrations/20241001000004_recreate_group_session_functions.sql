-- =====================================================
-- RECREATE ALL FUNCTIONS - PART 2: GROUP & SESSION FUNCTIONS
-- Date: 2024-10-01
-- Description: Continue recreating functions - Groups and Sessions
-- =====================================================

-- =====================================================
-- GROUP MANAGEMENT FUNCTIONS
-- =====================================================

CREATE OR REPLACE FUNCTION create_group(
    p_name TEXT, 
    p_created_by INTEGER, 
    p_description TEXT DEFAULT '', 
    p_is_public BOOLEAN DEFAULT false
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_group_id INTEGER;
    v_invite_code VARCHAR(12);
    result JSON;
BEGIN
    -- Check if created_by is allowed to create groups
    IF p_created_by < 2 THEN
        RAISE EXCEPTION 'Users with ID less than 2 are not allowed to create groups';
    END IF;
    
    -- Validate group name
    IF p_name IS NULL OR trim(p_name) = '' THEN
        RAISE EXCEPTION 'Group name is required' USING ERRCODE = '23514';
    END IF;
    
    -- Check if user exists
    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_created_by) THEN
        RAISE EXCEPTION 'Creator user with ID % not found', p_created_by USING ERRCODE = 'P0002';
    END IF;
    
    -- Insert new group (invite_code will be auto-generated by trigger)
    INSERT INTO groups (name, description, created_by, is_public, created_at)
    VALUES (p_name, p_description, p_created_by, p_is_public, NOW())
    RETURNING group_id, invite_code INTO v_group_id, v_invite_code;
    
    -- Add creator as admin member
    INSERT INTO group_participants (group_id, user_id, role, joined_at)
    VALUES (v_group_id, p_created_by, 'admin', NOW());
    
    -- Return success result with group details including invite_code
    SELECT json_build_object(
        'success', true,
        'group_id', v_group_id,
        'name', p_name,
        'description', p_description,
        'is_public', p_is_public,
        'invite_code', v_invite_code,
        'created_by', p_created_by,
        'created_at', NOW()
    ) INTO result;
    
    RETURN result;
EXCEPTION
    WHEN OTHERS THEN
        RAISE EXCEPTION 'Failed to create group: %', SQLERRM;
END;
$$;

CREATE OR REPLACE FUNCTION get_group_by_id(p_group_id INTEGER)
RETURNS TABLE(id INTEGER, name TEXT, description TEXT, member_count BIGINT, created_at TIMESTAMP)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.group_id::INTEGER as id,
        g.name,
        COALESCE(g.description, '') as description,
        COUNT(gp.user_id) as member_count,
        g.created_at
    FROM groups g
    LEFT JOIN group_participants gp ON g.group_id = gp.group_id
    WHERE g.group_id = p_group_id
    GROUP BY g.group_id, g.name, g.description, g.created_at;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION get_group_by_name(p_name TEXT)
RETURNS TABLE(id INTEGER, name TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.group_id::INTEGER as id,
        g.name
    FROM groups g
    WHERE LOWER(g.name) = LOWER(p_name)
    LIMIT 1;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Group with name ''%'' not found', p_name USING ERRCODE = 'P0002';
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION get_all_groups()
RETURNS TABLE(id INTEGER, name TEXT, description TEXT, member_count BIGINT, created_at TIMESTAMP)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        g.group_id::INTEGER as id,
        g.name,
        COALESCE(g.description, '') as description,
        COUNT(gp.user_id) as member_count,
        g.created_at
    FROM groups g
    LEFT JOIN group_participants gp ON g.group_id = gp.group_id
    GROUP BY g.group_id, g.name, g.description, g.created_at
    ORDER BY g.group_id;
END;
$$;

CREATE OR REPLACE FUNCTION add_group_member(
    p_group_id INTEGER, 
    p_user_id INTEGER, 
    p_role TEXT DEFAULT 'member'
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if group exists
    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user exists
    IF NOT EXISTS (SELECT 1 FROM users u WHERE u.user_id = p_user_id) THEN
        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user is already a member
    IF EXISTS (SELECT 1 FROM group_participants WHERE group_id = p_group_id AND user_id = p_user_id) THEN
        RAISE EXCEPTION 'User % is already a member of group %', p_user_id, p_group_id USING ERRCODE = '23505';
    END IF;
    
    -- Validate role
    IF p_role NOT IN ('admin', 'member', 'mentor') THEN
        RAISE EXCEPTION 'Invalid role. Must be admin, member, or mentor' USING ERRCODE = '23514';
    END IF;
    
    -- Add user to group
    INSERT INTO group_participants (group_id, user_id, role)
    VALUES (p_group_id, p_user_id, p_role);
    
    RETURN json_build_object('message', 'User ' || p_user_id || ' added to group ' || p_group_id);
END;
$$;

CREATE OR REPLACE FUNCTION remove_group_member(p_group_id INTEGER, p_user_id INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_deleted_count INTEGER;
BEGIN
    -- Check if group exists
    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Remove user from group
    DELETE FROM group_participants 
    WHERE group_id = p_group_id AND user_id = p_user_id;
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    
    IF v_deleted_count = 0 THEN
        RAISE EXCEPTION 'User % is not a member of group %', p_user_id, p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    RETURN true;
END;
$$;

CREATE OR REPLACE FUNCTION get_group_members(p_group_id INTEGER)
RETURNS TABLE(group_id INTEGER, member_ids INTEGER[], member_count BIGINT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_member_ids INTEGER[];
    v_count BIGINT;
BEGIN
    -- Check if group exists
    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Get member IDs
    SELECT ARRAY_AGG(gp.user_id), COUNT(gp.user_id)
    INTO v_member_ids, v_count
    FROM group_participants gp
    WHERE gp.group_id = p_group_id;
    
    RETURN QUERY
    SELECT 
        p_group_id as group_id,
        COALESCE(v_member_ids, ARRAY[]::INTEGER[]) as member_ids,
        COALESCE(v_count, 0) as member_count;
END;
$$;

CREATE OR REPLACE FUNCTION get_group_members_detailed(p_group_id INTEGER)
RETURNS TABLE(
    user_id INTEGER, 
    name TEXT, 
    email TEXT, 
    role VARCHAR(50), 
    joined_at TIMESTAMP, 
    is_active BOOLEAN, 
    first_name TEXT, 
    last_name TEXT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if group exists
    IF NOT EXISTS (SELECT 1 FROM groups WHERE group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;

    RETURN QUERY
    SELECT 
        u.user_id,
        COALESCE(
            TRIM(CONCAT(u.first_name, ' ', u.last_name)), 
            u.email
        ) as name,
        u.email,
        gp.role,
        gp.joined_at,
        CASE WHEN u.availability = 'available' THEN true ELSE false END as is_active,
        u.first_name,
        u.last_name
    FROM group_participants gp
    INNER JOIN users u ON gp.user_id = u.user_id
    WHERE gp.group_id = p_group_id
    ORDER BY gp.joined_at ASC;
END;
$$;

CREATE OR REPLACE FUNCTION join_group_by_invite_code(p_invite_code TEXT, p_user_id INTEGER)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_group_id INTEGER;
BEGIN
    -- Find group by invite code
    SELECT g.group_id INTO v_group_id
    FROM groups g
    WHERE g.invite_code = p_invite_code;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid invite code' USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user exists
    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN
        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user is already a member
    IF EXISTS (SELECT 1 FROM group_participants WHERE group_id = v_group_id AND user_id = p_user_id) THEN
        RAISE EXCEPTION 'User is already a member of this group' USING ERRCODE = '23505';
    END IF;
    
    -- Add user to group
    INSERT INTO group_participants (group_id, user_id, role)
    VALUES (v_group_id, p_user_id, 'member');
    
    RETURN json_build_object(
        'success', true,
        'message', 'Successfully joined group',
        'group_id', v_group_id
    );
END;
$$;

-- =====================================================
-- SESSION MANAGEMENT FUNCTIONS
-- =====================================================

CREATE OR REPLACE FUNCTION create_session(
    p_group_id INTEGER,
    p_created_by INTEGER,
    p_topic TEXT DEFAULT NULL,
    p_status VARCHAR(50) DEFAULT 'active'
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    description TEXT,
    created_by INTEGER,
    group_id INTEGER,
    created_at TIMESTAMP,
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    status VARCHAR(50),
    participant_count BIGINT
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_session_id INTEGER;
BEGIN
    -- Validate that group exists
    IF NOT EXISTS (SELECT 1 FROM groups WHERE group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Validate that user exists and is member of group
    IF NOT EXISTS (
        SELECT 1 FROM group_participants gp 
        WHERE gp.group_id = p_group_id AND gp.user_id = p_created_by
    ) THEN
        RAISE EXCEPTION 'User % is not a member of group %', p_created_by, p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Insert new session
    INSERT INTO sessions (group_id, created_by, topic, status, started_at)
    VALUES (p_group_id, p_created_by, p_topic, p_status, CURRENT_TIMESTAMP)
    RETURNING session_id INTO v_session_id;
    
    -- Add creator as participant
    INSERT INTO session_participants (session_id, user_id)
    VALUES (v_session_id, p_created_by)
    ON CONFLICT (session_id, user_id) DO NOTHING;
    
    -- Return created session
    RETURN QUERY
    SELECT 
        v_session_id as id,
        COALESCE(p_topic, 'Untitled Session') as title,
        ''::TEXT as description,
        p_created_by as created_by,
        p_group_id as group_id,
        CURRENT_TIMESTAMP as created_at,
        CURRENT_TIMESTAMP as started_at,
        NULL::TIMESTAMP as ended_at,
        p_status as status,
        1::BIGINT as participant_count;
END;
$$;

-- Alternative create_session function
CREATE OR REPLACE FUNCTION create_session(
    p_title TEXT,
    p_user_id INTEGER,
    p_group_id INTEGER DEFAULT 1
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    description TEXT,
    created_by INTEGER,
    group_id INTEGER,
    created_at TIMESTAMP,
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    status TEXT,
    participant_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_session_id INTEGER;
    v_final_title TEXT;
BEGIN
    -- Validate user exists
    IF NOT EXISTS (SELECT 1 FROM users u WHERE u.user_id = p_user_id) THEN
        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Validate group exists
    IF NOT EXISTS (SELECT 1 FROM groups g WHERE g.group_id = p_group_id) THEN
        RAISE EXCEPTION 'Group with ID % not found', p_group_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Set default title if not provided
    v_final_title := COALESCE(p_title, 'Session ' || TO_CHAR(CURRENT_TIMESTAMP, 'YYYYMMDD_HH24MISS'));
    
    -- Insert new session
    INSERT INTO sessions (group_id, created_by, topic, status, started_at)
    VALUES (p_group_id, p_user_id, v_final_title, 'active', CURRENT_TIMESTAMP)
    RETURNING session_id INTO v_session_id;
    
    -- Ensure user is a participant in the group
    INSERT INTO group_participants (group_id, user_id, role)
    VALUES (p_group_id, p_user_id, 'member')
    ON CONFLICT ON CONSTRAINT group_participants_group_id_user_id_key DO NOTHING;
    
    -- Return the created session
    RETURN QUERY
    SELECT 
        v_session_id as id,
        v_final_title as title,
        ''::TEXT as description,
        p_user_id as created_by,
        p_group_id as group_id,
        CURRENT_TIMESTAMP as created_at,
        CURRENT_TIMESTAMP as started_at,
        null::timestamp as ended_at,
        'active'::TEXT as status,
        0::BIGINT as participant_count;
END;
$$;

CREATE OR REPLACE FUNCTION get_session_by_id(p_session_id INTEGER)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    description TEXT,
    created_by INTEGER,
    group_id INTEGER,
    created_at TIMESTAMP,
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    status VARCHAR(50),
    participant_count BIGINT
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.session_id::INTEGER as id,
        COALESCE(s.topic, 'Untitled Session') as title,
        ''::TEXT as description,
        s.created_by::INTEGER as created_by,
        s.group_id::INTEGER as group_id,
        s.started_at as created_at,
        s.started_at as started_at,
        s.ended_at as ended_at,
        s.status as status,
        COUNT(DISTINCT sp.user_id) as participant_count
    FROM sessions s
    LEFT JOIN session_participants sp ON s.session_id = sp.session_id
    WHERE s.session_id = p_session_id
    GROUP BY s.session_id, s.topic, s.created_by, s.group_id, s.started_at, s.ended_at, s.status;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION get_session_by_title(p_title TEXT)
RETURNS TABLE(id INTEGER, title TEXT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.session_id::INTEGER as id,
        s.topic as title
    FROM sessions s
    WHERE LOWER(s.topic) = LOWER(p_title)
    LIMIT 1;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Session with title ''%'' not found', p_title USING ERRCODE = 'P0002';
    END IF;
END;
$$;

CREATE OR REPLACE FUNCTION get_all_sessions(
    p_user_id INTEGER DEFAULT NULL,
    p_is_active BOOLEAN DEFAULT NULL
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    description TEXT,
    created_by INTEGER,
    group_id INTEGER,
    created_at TIMESTAMP,
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    status VARCHAR(50),
    participant_count BIGINT
) 
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.session_id::INTEGER as id,
        COALESCE(s.topic, 'Untitled Session') as title,
        ''::TEXT as description,
        s.created_by::INTEGER as created_by,
        s.group_id::INTEGER as group_id,
        s.started_at as created_at,
        s.started_at as started_at,
        s.ended_at as ended_at,
        s.status as status,
        COUNT(DISTINCT sp.user_id) as participant_count
    FROM sessions s
    LEFT JOIN session_participants sp ON s.session_id = sp.session_id
    WHERE (p_user_id IS NULL OR s.created_by = p_user_id)
      AND (p_is_active IS NULL OR 
           (p_is_active = true AND s.status = 'active') OR
           (p_is_active = false AND s.status != 'active'))
    GROUP BY s.session_id, s.topic, s.created_by, s.group_id, s.started_at, s.ended_at, s.status
    ORDER BY s.session_id;
END;
$$;

CREATE OR REPLACE FUNCTION update_session(
    p_session_id INTEGER,
    p_title TEXT DEFAULT NULL,
    p_status TEXT DEFAULT NULL
)
RETURNS TABLE (
    id INTEGER,
    title TEXT,
    description TEXT,
    created_by INTEGER,
    group_id INTEGER,
    created_at TIMESTAMP,
    started_at TIMESTAMP,
    ended_at TIMESTAMP,
    status TEXT,
    participant_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_ended_at TIMESTAMP := NULL;
BEGIN
    -- Check if session exists
    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Validate status if provided
    IF p_status IS NOT NULL AND p_status NOT IN ('offline', 'active', 'completed') THEN
        RAISE EXCEPTION 'Invalid status. Must be offline, active, or completed' USING ERRCODE = '23514';
    END IF;
    
    -- Set ended_at if status is being changed to completed
    IF p_status = 'completed' THEN
        v_ended_at := CURRENT_TIMESTAMP;
    END IF;
    
    -- Update session with provided values
    UPDATE sessions 
    SET 
        topic = COALESCE(p_title, topic),
        status = COALESCE(p_status, status),
        ended_at = CASE WHEN p_status = 'completed' THEN v_ended_at ELSE ended_at END
    WHERE session_id = p_session_id;
    
    -- Return updated session using get_session_by_id
    RETURN QUERY
    SELECT * FROM get_session_by_id(p_session_id);
END;
$$;

CREATE OR REPLACE FUNCTION delete_session(p_session_id INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if session exists
    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Delete session (cascading deletes will handle related records)
    DELETE FROM sessions WHERE session_id = p_session_id;
    
    RETURN true;
END;
$$;

CREATE OR REPLACE FUNCTION add_session_participant(
    p_session_id INTEGER,
    p_user_id INTEGER
)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- Check if session exists
    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user exists
    IF NOT EXISTS (SELECT 1 FROM users WHERE user_id = p_user_id) THEN
        RAISE EXCEPTION 'User with ID % not found', p_user_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Check if user is already a participant
    IF EXISTS (SELECT 1 FROM session_participants WHERE session_id = p_session_id AND user_id = p_user_id) THEN
        RAISE EXCEPTION 'User % is already a participant in session %', p_user_id, p_session_id USING ERRCODE = '23505';
    END IF;
    
    -- Add user to session
    INSERT INTO session_participants (session_id, user_id)
    VALUES (p_session_id, p_user_id);
    
    RETURN json_build_object('message', 'User ' || p_user_id || ' added to session ' || p_session_id);
END;
$$;

CREATE OR REPLACE FUNCTION remove_session_participant(p_session_id INTEGER, p_user_id INTEGER)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_deleted_count INTEGER;
BEGIN
    -- Check if session exists
    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Remove user from session
    DELETE FROM session_participants 
    WHERE session_id = p_session_id AND user_id = p_user_id;
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    
    IF v_deleted_count = 0 THEN
        RAISE EXCEPTION 'User % is not a participant in session %', p_user_id, p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    RETURN true;
END;
$$;

CREATE OR REPLACE FUNCTION get_session_participants(p_session_id INTEGER)
RETURNS TABLE(session_id INTEGER, participant_ids INTEGER[], participant_count BIGINT)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_participant_ids INTEGER[];
    v_count BIGINT;
BEGIN
    -- Check if session exists
    IF NOT EXISTS (SELECT 1 FROM sessions WHERE session_id = p_session_id) THEN
        RAISE EXCEPTION 'Session with ID % not found', p_session_id USING ERRCODE = 'P0002';
    END IF;
    
    -- Get participant IDs
    SELECT ARRAY_AGG(sp.user_id), COUNT(sp.user_id)
    INTO v_participant_ids, v_count
    FROM session_participants sp
    WHERE sp.session_id = p_session_id;
    
    RETURN QUERY
    SELECT 
        p_session_id as session_id,
        COALESCE(v_participant_ids, ARRAY[]::INTEGER[]) as participant_ids,
        COALESCE(v_count, 0) as participant_count;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO anon;

-- Add comments for group functions
COMMENT ON FUNCTION create_group(TEXT, INTEGER, TEXT, BOOLEAN) IS 'Creates a new group with name, creator, description and visibility';
COMMENT ON FUNCTION get_group_by_id(INTEGER) IS 'Retrieves group details by ID with member count';
COMMENT ON FUNCTION get_group_by_name(TEXT) IS 'Finds group by name (case insensitive)';
COMMENT ON FUNCTION get_all_groups() IS 'Returns all groups with member counts';
COMMENT ON FUNCTION add_group_member(INTEGER, INTEGER, TEXT) IS 'Adds a user to a group with specified role';
COMMENT ON FUNCTION remove_group_member(INTEGER, INTEGER) IS 'Removes a user from a group';
COMMENT ON FUNCTION get_group_members(INTEGER) IS 'Returns array of member IDs for a group';
COMMENT ON FUNCTION get_group_members_detailed(INTEGER) IS 'Returns detailed member information for a group';
COMMENT ON FUNCTION join_group_by_invite_code(TEXT, INTEGER) IS 'Allows user to join group using invite code';

-- Add comments for session functions
COMMENT ON FUNCTION create_session(INTEGER, INTEGER, TEXT, VARCHAR) IS 'Creates a new session for a group with specified parameters';
COMMENT ON FUNCTION create_session(TEXT, INTEGER, INTEGER) IS 'Alternative create session function using title instead of topic';
COMMENT ON FUNCTION get_session_by_id(INTEGER) IS 'Retrieves session details by ID with participant count';
COMMENT ON FUNCTION get_session_by_title(TEXT) IS 'Finds session by title/topic';
COMMENT ON FUNCTION get_all_sessions(INTEGER, BOOLEAN) IS 'Returns all sessions with optional user and active filters';
COMMENT ON FUNCTION update_session(INTEGER, TEXT, TEXT) IS 'Updates session title and/or status';
COMMENT ON FUNCTION delete_session(INTEGER) IS 'Permanently deletes a session and related data';
COMMENT ON FUNCTION add_session_participant(INTEGER, INTEGER) IS 'Adds a user to a session';
COMMENT ON FUNCTION remove_session_participant(INTEGER, INTEGER) IS 'Removes a user from a session';
COMMENT ON FUNCTION get_session_participants(INTEGER) IS 'Returns array of participant IDs for a session';

-- =====================================================
-- VERIFICATION
-- =====================================================

DO $$
BEGIN
    RAISE NOTICE 'Group and Session management functions recreated successfully';
    RAISE NOTICE '✅ Group CRUD operations';
    RAISE NOTICE '✅ Group member management';
    RAISE NOTICE '✅ Group invite system';
    RAISE NOTICE '✅ Session CRUD operations'; 
    RAISE NOTICE '✅ Session participant management';
    RAISE NOTICE 'Ready for Part 3: Message, Paper, and remaining functions...';
END $$;
